/* drivers/input/touchscreen/gt9xx_shorttp.c
 *
 * 2010 - 2012 Goodix Technology.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be a reference
 * to you, when you are integrating the GOODiX's CTP IC into your system,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * Version:1.0
 * Author: meta@goodix.com
 * Accomplished Date:2012/10/20
 * Revision record:
 *
 */

#include <gt928_openshort.h>
#include <linux/slab.h> // add by leo for kzalloc
#include <linux/proc_fs.h> // add by leo for proc
#include <linux/debugfs.h> // add by leo for proc


#define GTP_TEST_INFO_MAX		1460

// short test
#define GTP_SHORT_GND
#define GTP_VDD         33      // 3.3V

// open test
u16 max_limit_value = 2000; // screen max limit
u16 min_limit_value = 1200;  // screen min limit
u16 max_limit_key = 1631;       // key_val max limit
u16 min_limit_key = 625;        // key_val min limit


extern void gtp_irq_disable(struct goodix_ts_data *ts);
extern void gtp_irq_enable(struct goodix_ts_data *ts);
extern void gtp_reset_guitar(struct i2c_client*, s32);
extern s8 gtp_enter_sleep(struct goodix_ts_data * ts);
extern s8 gtp_wakeup_sleep(struct goodix_ts_data * ts);
extern s32 gtp_i2c_read(struct i2c_client *, u8 *, s32);
extern s32 gtp_i2c_write(struct i2c_client *, u8 *, s32);
extern s32 gup_enter_update_mode(struct i2c_client *);
extern s32 gup_leave_update_mode(void);
extern s32 gtp_send_cfg(struct i2c_client *client);
extern s32 gtp_read_version(struct i2c_client *client, u16* version);

extern s8 gtp_enter_sleep(struct goodix_ts_data * ts);
extern s8 gtp_wakeup_sleep(struct goodix_ts_data * ts);

extern struct i2c_client * i2c_connect_client;
extern u8 config[GTP_ADDR_LENGTH + GTP_CONFIG_MAX_LENGTH];

u8  gt9xx_drv_num = MAX_DRIVER_NUM;	// default driver and sensor number
u8  gt9xx_sen_num = MAX_SENSOR_NUM;
u16 gt9xx_pixel_cnt = MAX_DRIVER_NUM * MAX_SENSOR_NUM;
u16 gt9xx_sc_pxl_cnt = MAX_DRIVER_NUM * MAX_SENSOR_NUM;
struct gt9xx_short_info *short_sum;

#if GTP_HAVE_TOUCH_KEY
u8 gt9xx_sc_drv_num;
u8 key_is_isolated;	// 0: no, 1: yes
u8 key_iso_pos[5];
#endif

struct kobject *goodix_debug_kobj;
static s32 sample_set_num = 16;
static u32 default_test_types = _MAX_TEST | _MIN_TEST | _KEY_MAX_TEST | _KEY_MIN_TEST;
static u8  rslt_buf_idx = 0;
static s32 *test_rslt_buf;
static struct gt9xx_open_info *touchpad_sum;

#define _MIN_ERROR_NUM      (sample_set_num	* 9 / 10)

static char *result_lines[GTP_TEST_INFO_MAX];
static char tmp_info_line[GTP_TEST_INFO_MAX];
static u8 RsltIndex;

// add by leo for dump raw data ++
u16 gt928_raw_data[MAX_DRIVER_NUM * MAX_SENSOR_NUM] = {0};
u16 gt928_acc_data[MAX_DRIVER_NUM * MAX_SENSOR_NUM] = {0};

#define TEST_CONFIG_FILE_PATH	"/data/gt928_test_config.ini"
#define	GT928_PROC_TEST_FILE	"gt928_test"
#define	GT928_PROC_DIAG_FILE	"gt928_diag"

static struct proc_dir_entry *gt928_proc_test_file;
static struct proc_dir_entry *gt928_proc_diag_file;

void gt928_create_proc_test_file(void);
void gt928_remove_proc_test_file(void);
void gt928_create_proc_diag_file(void);
void gt928_remove_proc_diag_file(void);
// add by leo for dump raw data --

static void append_info_line(void)
{
	if (strlen(tmp_info_line) != 0)
	{
		result_lines[RsltIndex] = (char *)kzalloc(strlen(tmp_info_line)+1, GFP_KERNEL);
		memcpy(result_lines[RsltIndex], tmp_info_line, strlen(tmp_info_line));
	}
	if (RsltIndex != (GTP_TEST_INFO_MAX-1))
		++RsltIndex;
	else
	{
		kfree(result_lines[RsltIndex]);
	}
	return;
}

#define SET_INFO_SHORT_INFO(fmt, args...)       do{ memset(tmp_info_line, '\0', 80);\
		sprintf(tmp_info_line, " "fmt, ##args);\
		printk(fmt, ##args);\
		append_info_line();} while(0)

#define SET_INFO_LINE_INFO(fmt, args...)       do{ memset(tmp_info_line, '\0', 80);\
		sprintf(tmp_info_line, "<Sysfs-INFO>"fmt"\n", ##args);\
		GTP_INFO(fmt, ##args);\
		append_info_line();} while(0)

#define SET_INFO_LINE_ERR(fmt, args...)        do { memset(tmp_info_line, '\0', 80);\
		sprintf(tmp_info_line, "<Sysfs-ERROR>"fmt"\n", ##args);\
		GTP_ERROR(fmt, ##args);\
		append_info_line();}while(0)


static u8 cfg_drv_order[MAX_DRIVER_NUM];
static u8 cfg_sen_order[MAX_SENSOR_NUM];

/*
 * Initialize cfg_drv_order and cfg_sen_order, which is used for report short channels
 *
 */

// add by leo for dynamic change limit value ++
struct gt9xx_tp_raw_acc_info
{
	u16 node_number;
	u16 max_rawdata;
	u16 min_rawdata;
	u16 acc_data;
};
static struct gt9xx_tp_raw_acc_info *gt928_raw_acc_spec = NULL;

//AUO + GIS Spec B
static u16 GuitarTestPlatformINI_GIS[TOTAL_PIXEL_NUM*4]=
{
	0,4800,1100,450,1,4800,1100,550,2,4800,1100,250,3,4800,1100,250,4,4800,1100,250,5,4800,1100,250,6,4800,1100,250,7,4800,1100,250,8,4800,1100,250,9,4800,1100,250,10,4800,1100,250,11,4800,1100,250,12,4800,1100,250,13,4800,1100,250,14,4800,1100,250,15,4800,1100,250,16,4800,1100,250,17,4800,1100,250,18,4800,1100,250,19,4800,1100,250,20,4800,1100,250,21,4800,1100,250,22,4800,1100,250,23,4800,1100,250,24,4800,1100,250,25,4800,1100,250,26,4800,1100,250,27,4800,1100,250,28,4800,1100,250,29,4800,1100,250,30,4800,1100,450,31,4800,1100,380,32,4800,1100,350,33,4800,1100,430,34,4800,1100,250,35,4800,1100,250,36,4800,1100,250,37,4800,1100,250,38,4800,1100,250,39,4800,1100,250,40,4800,1100,250,41,4800,1100,250,42,4800,1100,250,43,4800,1100,250,44,4800,1100,250,45,4800,1100,250,46,4800,1100,250,47,4800,1100,250,48,4800,1100,250,49,4800,1100,250,50,4800,1100,250,51,4800,1100,250,52,4800,1100,250,53,4800,1100,250,54,4800,1100,250,55,4800,1100,250,56,4800,1100,250,57,4800,1100,250,58,4800,1100,250,59,4800,1100,250,60,4800,1100,250,61,4800,1100,250,62,4800,1100,450,63,4800,1100,380,64,4800,1100,300,65,4800,1100,350,66,4800,1100,250,67,4800,1100,250,68,4800,1100,250,69,4800,1100,250,70,4800,1100,250,71,4800,1100,250,72,4800,1100,250,73,4800,1100,250,74,4800,1100,250,75,4800,1100,250,76,4800,1100,250,77,4800,1100,250,78,4800,1100,250,79,4800,1100,250,80,4800,1100,250,81,4800,1100,250,82,4800,1100,250,83,4800,1100,250,84,4800,1100,250,85,4800,1100,250,86,4800,1100,250,87,4800,1100,250,88,4800,1100,250,89,4800,1100,250,90,4800,1100,250,91,4800,1100,250,92,4800,1100,250,93,4800,1100,250,94,4800,1100,450,95,4800,1100,380,96,4800,1100,300,97,4800,1100,350,98,4800,1100,250,99,4800,1100,250,100,4800,1100,250,101,4800,1100,250,102,4800,1100,250,103,4800,1100,250,104,4800,1100,250,105,4800,1100,250,106,4800,1100,250,107,4800,1100,250,108,4800,1100,250,109,4800,1100,250,110,4800,1100,250,111,4800,1100,250,112,4800,1100,250,113,4800,1100,250,114,4800,1100,250,115,4800,1100,250,116,4800,1100,250,117,4800,1100,250,118,4800,1100,250,119,4800,1100,250,120,4800,1100,250,121,4800,1100,250,122,4800,1100,250,123,4800,1100,250,124,4800,1100,250,125,4800,1100,250,126,4800,1100,450,127,4800,1100,380,128,4800,1100,300,129,4800,1100,350,130,4800,1100,250,131,4800,1100,250,132,4800,1100,250,133,4800,1100,250,134,4800,1100,250,135,4800,1100,250,136,4800,1100,250,137,4800,1100,250,138,4800,1100,250,139,4800,1100,250,140,4800,1100,250,141,4800,1100,250,142,4800,1100,250,143,4800,1100,250,144,4800,1100,250,145,4800,1100,250,146,4800,1100,250,147,4800,1100,250,148,4800,1100,250,149,4800,1100,250,150,4800,1100,250,151,4800,1100,250,152,4800,1100,250,153,4800,1100,250,154,4800,1100,250,155,4800,1100,250,156,4800,1100,250,157,4800,1100,250,158,4800,1100,450,159,4800,1100,380,160,4800,1100,300,161,4800,1100,350,162,4800,1100,250,163,4800,1100,250,164,4800,1100,250,165,4800,1100,250,166,4800,1100,250,167,4800,1100,250,168,4800,1100,250,169,4800,1100,250,170,4800,1100,250,171,4800,1100,250,172,4800,1100,250,173,4800,1100,250,174,4800,1100,250,175,4800,1100,250,176,4800,1100,250,177,4800,1100,250,178,4800,1100,250,179,4800,1100,250,180,4800,1100,250,181,4800,1100,250,182,4800,1100,250,183,4800,1100,250,184,4800,1100,250,185,4800,1100,250,186,4800,1100,250,187,4800,1100,250,188,4800,1100,250,189,4800,1100,250,190,4800,1100,450,191,4800,1100,380,192,4800,1100,300,193,4800,1100,350,194,4800,1100,250,195,4800,1100,250,196,4800,1100,250,197,4800,1100,250,198,4800,1100,250,199,4800,1100,250,200,4800,1100,250,201,4800,1100,250,202,4800,1100,250,203,4800,1100,250,204,4800,1100,250,205,4800,1100,250,206,4800,1100,250,207,4800,1100,250,208,4800,1100,250,209,4800,1100,250,210,4800,1100,250,211,4800,1100,250,212,4800,1100,250,213,4800,1100,250,214,4800,1100,250,215,4800,1100,250,216,4800,1100,250,217,4800,1100,250,218,4800,1100,250,219,4800,1100,250,220,4800,1100,250,221,4800,1100,250,222,4800,1100,450,223,4800,1100,380,224,4800,1100,300,225,4800,1100,350,226,4800,1100,250,227,4800,1100,250,228,4800,1100,250,229,4800,1100,250,230,4800,1100,250,231,4800,1100,250,232,4800,1100,250,233,
	4800,1100,250,234,4800,1100,250,235,4800,1100,250,236,4800,1100,250,237,4800,1100,250,238,4800,1100,250,239,4800,1100,250,240,4800,1100,250,241,4800,1100,250,242,4800,1100,250,243,4800,1100,250,244,4800,1100,250,245,4800,1100,250,246,4800,1100,250,247,4800,1100,250,248,4800,1100,250,249,4800,1100,250,250,4800,1100,250,251,4800,1100,250,252,4800,1100,250,253,4800,1100,250,254,4800,1100,450,255,4800,1100,380,256,4800,1100,300,257,4800,1100,350,258,4800,1100,250,259,4800,1100,250,260,4800,1100,250,261,4800,1100,250,262,4800,1100,250,263,4800,1100,250,264,4800,1100,250,265,4800,1100,250,266,4800,1100,250,267,4800,1100,250,268,4800,1100,250,269,4800,1100,250,270,4800,1100,250,271,4800,1100,250,272,4800,1100,250,273,4800,1100,250,274,4800,1100,250,275,4800,1100,250,276,4800,1100,250,277,4800,1100,250,278,4800,1100,250,279,4800,1100,250,280,4800,1100,250,281,4800,1100,250,282,4800,1100,250,283,4800,1100,250,284,4800,1100,250,285,4800,1100,250,286,4800,1100,450,287,4800,1100,380,288,4800,1100,300,289,4800,1100,350,290,4800,1100,250,291,4800,1100,250,292,4800,1100,250,293,4800,1100,250,294,4800,1100,250,295,4800,1100,250,296,4800,1100,250,297,4800,1100,250,298,4800,1100,250,299,4800,1100,250,300,4800,1100,250,301,4800,1100,250,302,4800,1100,250,303,4800,1100,250,304,4800,1100,250,305,4800,1100,250,306,4800,1100,250,307,4800,1100,250,308,4800,1100,250,309,4800,1100,250,310,4800,1100,250,311,4800,1100,250,312,4800,1100,250,313,4800,1100,250,314,4800,1100,250,315,4800,1100,250,316,4800,1100,250,317,4800,1100,250,318,4800,1100,450,319,4800,1100,380,320,4800,1100,300,321,4800,1100,350,322,4800,1100,250,323,4800,1100,250,324,4800,1100,250,325,4800,1100,250,326,4800,1100,250,327,4800,1100,250,328,4800,1100,250,329,4800,1100,250,330,4800,1100,250,331,4800,1100,250,332,4800,1100,250,333,4800,1100,250,334,4800,1100,250,335,4800,1100,250,336,4800,1100,250,337,4800,1100,250,338,4800,1100,250,339,4800,1100,250,340,4800,1100,250,341,4800,1100,250,342,4800,1100,250,343,4800,1100,250,344,4800,1100,250,345,4800,1100,250,346,4800,1100,250,347,4800,1100,250,348,4800,1100,250,349,4800,1100,250,350,4800,1100,450,351,4800,1100,380,352,4800,1100,300,353,4800,1100,350,354,4800,1100,250,355,4800,1100,250,356,4800,1100,250,357,4800,1100,250,358,4800,1100,250,359,4800,1100,250,360,4800,1100,250,361,4800,1100,250,362,4800,1100,250,363,4800,1100,250,364,4800,1100,250,365,4800,1100,250,366,4800,1100,250,367,4800,1100,250,368,4800,1100,250,369,4800,1100,250,370,4800,1100,250,371,4800,1100,250,372,4800,1100,250,373,4800,1100,250,374,4800,1100,250,375,4800,1100,250,376,4800,1100,250,377,4800,1100,250,378,4800,1100,250,379,4800,1100,250,380,4800,1100,250,381,4800,1100,250,382,4800,1100,450,383,4800,1100,380,384,4800,1100,300,385,4800,1100,350,386,4800,1100,250,387,4800,1100,250,388,4800,1100,250,389,4800,1100,250,390,4800,1100,250,391,4800,1100,250,392,4800,1100,250,393,4800,1100,250,394,4800,1100,250,395,4800,1100,250,396,4800,1100,250,397,4800,1100,250,398,4800,1100,250,399,4800,1100,250,400,4800,1100,250,401,4800,1100,250,402,4800,1100,250,403,4800,1100,250,404,4800,1100,250,405,4800,1100,250,406,4800,1100,250,407,4800,1100,250,408,4800,1100,250,409,4800,1100,250,410,4800,1100,250,411,4800,1100,250,412,4800,1100,250,413,4800,1100,250,414,4800,1100,450,415,4800,1100,380,416,4800,1100,300,417,4800,1100,350,418,4800,1100,250,419,4800,1100,250,420,4800,1100,250,421,4800,1100,250,422,4800,1100,250,423,4800,1100,250,424,4800,1100,250,425,4800,1100,250,426,4800,1100,250,427,4800,1100,250,428,4800,1100,250,429,4800,1100,250,430,4800,1100,250,431,4800,1100,250,432,4800,1100,250,433,4800,1100,250,434,4800,1100,250,435,4800,1100,250,436,4800,1100,250,437,4800,1100,250,438,4800,1100,250,439,4800,1100,250,440,4800,1100,250,441,4800,1100,250,442,4800,1100,250,443,4800,1100,250,444,4800,1100,250,445,4800,1100,250,446,4800,1100,450,447,4800,1100,380,448,4800,1100,300,449,4800,1100,350,450,4800,1100,250,451,4800,1100,250,452,4800,1100,250,453,4800,1100,250,454,4800,1100,250,455,4800,1100,250,456,4800,1100,250,457,4800,1100,250,458,4800,1100,250,459,4800,1100,250,460,4800
	,1100,250,461,4800,1100,250,462,4800,1100,250,463,4800,1100,250,464,4800,1100,250,465,4800,1100,250,466,4800,1100,250,467,4800,1100,250,468,4800,1100,250,469,4800,1100,250,470,4800,1100,250,471,4800,1100,250,472,4800,1100,250,473,4800,1100,250,474,4800,1100,250,475,4800,1100,250,476,4800,1100,250,477,4800,1100,250,478,4800,1100,450,479,4800,1100,380,480,4800,1100,300,481,4800,1100,350,482,4800,1100,250,483,4800,1100,250,484,4800,1100,250,485,4800,1100,250,486,4800,1100,250,487,4800,1100,250,488,4800,1100,250,489,4800,1100,250,490,4800,1100,250,491,4800,1100,250,492,4800,1100,250,493,4800,1100,250,494,4800,1100,250,495,4800,1100,250,496,4800,1100,250,497,4800,1100,250,498,4800,1100,250,499,4800,1100,250,500,4800,1100,250,501,4800,1100,250,502,4800,1100,250,503,4800,1100,250,504,4800,1100,250,505,4800,1100,250,506,4800,1100,250,507,4800,1100,250,508,4800,1100,250,509,4800,1100,250,510,4800,1100,450,511,4800,1100,380,512,4800,1100,300,513,4800,1100,350,514,4800,1100,250,515,4800,1100,250,516,4800,1100,250,517,4800,1100,250,518,4800,1100,250,519,4800,1100,250,520,4800,1100,250,521,4800,1100,250,522,4800,1100,250,523,4800,1100,250,524,4800,1100,250,525,4800,1100,250,526,4800,1100,250,527,4800,1100,250,528,4800,1100,250,529,4800,1100,250,530,4800,1100,250,531,4800,1100,250,532,4800,1100,250,533,4800,1100,250,534,4800,1100,250,535,4800,1100,250,536,4800,1100,250,537,4800,1100,250,538,4800,1100,250,539,4800,1100,250,540,4800,1100,250,541,4800,1100,250,542,4800,1100,450,543,4800,1100,380,544,4800,1100,300,545,4800,1100,350,546,4800,1100,250,547,4800,1100,250,548,4800,1100,250,549,4800,1100,250,550,4800,1100,250,551,4800,1100,250,552,4800,1100,250,553,4800,1100,250,554,4800,1100,250,555,4800,1100,250,556,4800,1100,250,557,4800,1100,250,558,4800,1100,250,559,4800,1100,250,560,4800,1100,250,561,4800,1100,250,562,4800,1100,250,563,4800,1100,250,564,4800,1100,250,565,4800,1100,250,566,4800,1100,250,567,4800,1100,250,568,4800,1100,250,569,4800,1100,250,570,4800,1100,250,571,4800,1100,250,572,4800,1100,250,573,4800,1100,250,574,4800,1100,450,575,4800,1100,380,576,4800,1100,300,577,4800,1100,350,578,4800,1100,250,579,4800,1100,250,580,4800,1100,250,581,4800,1100,250,582,4800,1100,250,583,4800,1100,250,584,4800,1100,250,585,4800,1100,250,586,4800,1100,250,587,4800,1100,250,588,4800,1100,250,589,4800,1100,250,590,4800,1100,250,591,4800,1100,250,592,4800,1100,250,593,4800,1100,250,594,4800,1100,250,595,4800,1100,250,596,4800,1100,250,597,4800,1100,250,598,4800,1100,250,599,4800,1100,250,600,4800,1100,250,601,4800,1100,250,602,4800,1100,250,603,4800,1100,250,604,4800,1100,250,605,4800,1100,250,606,4800,1100,450,607,4800,1100,380,608,4800,1100,300,609,4800,1100,350,610,4800,1100,250,611,4800,1100,250,612,4800,1100,250,613,4800,1100,250,614,4800,1100,250,615,4800,1100,250,616,4800,1100,250,617,4800,1100,250,618,4800,1100,250,619,4800,1100,250,620,4800,1100,250,621,4800,1100,250,622,4800,1100,250,623,4800,1100,250,624,4800,1100,250,625,4800,1100,250,626,4800,1100,250,627,4800,1100,250,628,4800,1100,250,629,4800,1100,250,630,4800,1100,250,631,4800,1100,250,632,4800,1100,250,633,4800,1100,250,634,4800,1100,250,635,4800,1100,250,636,4800,1100,250,637,4800,1100,250,638,4800,1100,450,639,4800,1100,380,640,4800,1100,300,641,4800,1100,350,642,4800,1100,250,643,4800,1100,250,644,4800,1100,250,645,4800,1100,250,646,4800,1100,250,647,4800,1100,250,648,4800,1100,250,649,4800,1100,250,650,4800,1100,250,651,4800,1100,250,652,4800,1100,250,653,4800,1100,250,654,4800,1100,250,655,4800,1100,250,656,4800,1100,250,657,4800,1100,250,658,4800,1100,250,659,4800,1100,250,660,4800,1100,250,661,4800,1100,250,662,4800,1100,250,663,4800,1100,250,664,4800,1100,250,665,4800,1100,250,666,4800,1100,250,667,4800,1100,250,668,4800,1100,250,669,4800,1100,250,670,4800,1100,450,671,4800,1100,380,672,4800,1100,300,673,4800,1100,350,674,4800,1100,250,675,4800,1100,250,676,4800,1100,250,677,4800,1100,250,678,4800,1100,250,679,4800,1100,250,680,4800,1100,250,681,4800,1100,250,682,4800,1100,250,683,4800,1100,250,684,4800,1100,250,685,4800,1100,250,686,4800,1100,250,687,4800,
	1100,250,688,4800,1100,250,689,4800,1100,250,690,4800,1100,250,691,4800,1100,250,692,4800,1100,250,693,4800,1100,250,694,4800,1100,250,695,4800,1100,250,696,4800,1100,250,697,4800,1100,250,698,4800,1100,250,699,4800,1100,250,700,4800,1100,250,701,4800,1100,250,702,4800,1100,450,703,4800,1100,380,704,4800,1100,300,705,4800,1100,350,706,4800,1100,250,707,4800,1100,250,708,4800,1100,250,709,4800,1100,250,710,4800,1100,250,711,4800,1100,250,712,4800,1100,250,713,4800,1100,250,714,4800,1100,250,715,4800,1100,250,716,4800,1100,250,717,4800,1100,250,718,4800,1100,250,719,4800,1100,250,720,4800,1100,250,721,4800,1100,250,722,4800,1100,250,723,4800,1100,250,724,4800,1100,250,725,4800,1100,250,726,4800,1100,250,727,4800,1100,250,728,4800,1100,250,729,4800,1100,250,730,4800,1100,250,731,4800,1100,250,732,4800,1100,250,733,4800,1100,250,734,4800,1100,450,735,4800,1100,380,736,4800,1100,300,737,4800,1100,350,738,4800,1100,250,739,4800,1100,250,740,4800,1100,250,741,4800,1100,250,742,4800,1100,250,743,4800,1100,250,744,4800,1100,250,745,4800,1100,250,746,4800,1100,250,747,4800,1100,250,748,4800,1100,250,749,4800,1100,250,750,4800,1100,250,751,4800,1100,250,752,4800,1100,250,753,4800,1100,250,754,4800,1100,250,755,4800,1100,250,756,4800,1100,250,757,4800,1100,250,758,4800,1100,250,759,4800,1100,250,760,4800,1100,250,761,4800,1100,250,762,4800,1100,250,763,4800,1100,250,764,4800,1100,250,765,4800,1100,250,766,4800,1100,450,767,4800,1100,380,
};

//TopTouch Spec B
static u16 GuitarTestPlatformINI_TOPTOUCH[TOTAL_PIXEL_NUM*4]=
{
	0,3700,1100,250,1,3700,1100,250,2,3700,1100,250,3,3700,1100,250,4,3700,1100,250,5,3700,1100,250,6,3700,1100,250,7,3700,1100,250,8,3700,1100,250,9,3700,1100,250,10,3700,1100,250,11,3700,1100,250,12,3700,1100,250,13,3700,1100,250,14,3700,1100,250,15,3700,1100,250,16,3700,1100,250,17,3700,1100,250,18,3700,1100,250,19,3700,1100,250,20,3700,1100,250,21,3700,1100,250,22,3700,1100,250,23,3700,1100,250,24,3700,1100,250,25,3700,1100,250,26,3700,1100,250,27,3700,1100,250,28,3700,1100,250,29,3700,1100,250,30,3700,1100,250,31,3700,1100,250,32,3700,1100,250,33,3700,1100,250,34,3700,1100,250,35,3700,1100,250,36,3700,1100,250,37,3700,1100,250,38,3700,1100,250,39,3700,1100,250,40,3700,1100,250,41,3700,1100,250,42,3700,1100,250,43,3700,1100,250,44,3700,1100,250,45,3700,1100,250,46,3700,1100,250,47,3700,1100,250,48,3700,1100,250,49,3700,1100,250,50,3700,1100,250,51,3700,1100,250,52,3700,1100,250,53,3700,1100,250,54,3700,1100,250,55,3700,1100,250,56,3700,1100,250,57,3700,1100,250,58,3700,1100,250,59,3700,1100,250,60,3700,1100,250,61,3700,1100,250,62,3700,1100,250,63,3700,1100,250,64,3700,1100,250,65,3700,1100,250,66,3700,1100,250,67,3700,1100,250,68,3700,1100,250,69,3700,1100,250,70,3700,1100,250,71,3700,1100,250,72,3700,1100,250,73,3700,1100,250,74,3700,1100,250,75,3700,1100,250,76,3700,1100,250,77,3700,1100,250,78,3700,1100,250,79,3700,1100,250,80,3700,1100,250,81,3700,1100,250,82,3700,1100,250,83,3700,1100,250,84,3700,1100,250,85,3700,1100,250,86,3700,1100,250,87,3700,1100,250,88,3700,1100,250,89,3700,1100,250,90,3700,1100,250,91,3700,1100,250,92,3700,1100,250,93,3700,1100,250,94,3700,1100,250,95,3700,1100,250,96,3700,1100,250,97,3700,1100,250,98,3700,1100,250,99,3700,1100,250,100,3700,1100,250,101,3700,1100,250,102,3700,1100,250,103,3700,1100,250,104,3700,1100,250,105,3700,1100,250,106,3700,1100,250,107,3700,1100,250,108,3700,1100,250,109,3700,1100,250,110,3700,1100,250,111,3700,1100,250,112,3700,1100,250,113,3700,1100,250,114,3700,1100,250,115,3700,1100,250,116,3700,1100,250,117,3700,1100,250,118,3700,1100,250,119,3700,1100,250,120,3700,1100,250,121,3700,1100,250,122,3700,1100,250,123,3700,1100,250,124,3700,1100,250,125,3700,1100,250,126,3700,1100,250,127,3700,1100,250,128,3700,1100,250,129,3700,1100,250,130,3700,1100,250,131,3700,1100,250,132,3700,1100,250,133,3700,1100,250,134,3700,1100,250,135,3700,1100,250,136,3700,1100,250,137,3700,1100,250,138,3700,1100,250,139,3700,1100,250,140,3700,1100,250,141,3700,1100,250,142,3700,1100,250,143,3700,1100,250,144,3700,1100,250,145,3700,1100,250,146,3700,1100,250,147,3700,1100,250,148,3700,1100,250,149,3700,1100,250,150,3700,1100,250,151,3700,1100,250,152,3700,1100,250,153,3700,1100,250,154,3700,1100,250,155,3700,1100,250,156,3700,1100,250,157,3700,1100,250,158,3700,1100,250,159,3700,1100,250,160,3700,1100,250,161,3700,1100,250,162,3700,1100,250,163,3700,1100,250,164,3700,1100,250,165,3700,1100,250,166,3700,1100,250,167,3700,1100,250,168,3700,1100,250,169,3700,1100,250,170,3700,1100,250,171,3700,1100,250,172,3700,1100,250,173,3700,1100,250,174,3700,1100,250,175,3700,1100,250,176,3700,1100,250,177,3700,1100,250,178,3700,1100,250,179,3700,1100,250,180,3700,1100,250,181,3700,1100,250,182,3700,1100,250,183,3700,1100,250,184,3700,1100,250,185,3700,1100,250,186,3700,1100,250,187,3700,1100,250,188,3700,1100,250,189,3700,1100,250,190,3700,1100,250,191,3700,1100,250,192,3700,1100,250,193,3700,1100,250,194,3700,1100,250,195,3700,1100,250,196,3700,1100,250,197,3700,1100,250,198,3700,1100,250,199,3700,1100,250,200,3700,1100,250,201,3700,1100,250,202,3700,1100,250,203,3700,1100,250,204,3700,1100,250,205,3700,1100,250,206,3700,1100,250,207,3700,1100,250,208,3700,1100,250,209,3700,1100,250,210,3700,1100,250,211,3700,1100,250,212,3700,1100,250,213,3700,1100,250,214,3700,1100,250,215,3700,1100,250,216,3700,1100,250,217,3700,1100,250,218,3700,1100,250,219,3700,1100,250,220,3700,1100,250,221,3700,1100,250,222,3700,1100,250,223,3700,1100,250,224,3700,1100,250,225,3700,1100,250,226,3700,1100,250,227,3700,1100,250,228,3700,1100,250,229,3700,1100,250,230,3700,1100,250,231,3700,1100,250,232,3700,1100,250,233,
	3700,1100,250,234,3700,1100,250,235,3700,1100,250,236,3700,1100,250,237,3700,1100,250,238,3700,1100,250,239,3700,1100,250,240,3700,1100,250,241,3700,1100,250,242,3700,1100,250,243,3700,1100,250,244,3700,1100,250,245,3700,1100,250,246,3700,1100,250,247,3700,1100,250,248,3700,1100,250,249,3700,1100,250,250,3700,1100,250,251,3700,1100,250,252,3700,1100,250,253,3700,1100,250,254,3700,1100,250,255,3700,1100,250,256,3700,1100,250,257,3700,1100,250,258,3700,1100,250,259,3700,1100,250,260,3700,1100,250,261,3700,1100,250,262,3700,1100,250,263,3700,1100,250,264,3700,1100,250,265,3700,1100,250,266,3700,1100,250,267,3700,1100,250,268,3700,1100,250,269,3700,1100,250,270,3700,1100,250,271,3700,1100,250,272,3700,1100,250,273,3700,1100,250,274,3700,1100,250,275,3700,1100,250,276,3700,1100,250,277,3700,1100,250,278,3700,1100,250,279,3700,1100,250,280,3700,1100,250,281,3700,1100,250,282,3700,1100,250,283,3700,1100,250,284,3700,1100,250,285,3700,1100,250,286,3700,1100,250,287,3700,1100,250,288,3700,1100,250,289,3700,1100,250,290,3700,1100,250,291,3700,1100,250,292,3700,1100,250,293,3700,1100,250,294,3700,1100,250,295,3700,1100,250,296,3700,1100,250,297,3700,1100,250,298,3700,1100,250,299,3700,1100,250,300,3700,1100,250,301,3700,1100,250,302,3700,1100,250,303,3700,1100,250,304,3700,1100,250,305,3700,1100,250,306,3700,1100,250,307,3700,1100,250,308,3700,1100,250,309,3700,1100,250,310,3700,1100,250,311,3700,1100,250,312,3700,1100,250,313,3700,1100,250,314,3700,1100,250,315,3700,1100,250,316,3700,1100,250,317,3700,1100,250,318,3700,1100,250,319,3700,1100,250,320,3700,1100,250,321,3700,1100,250,322,3700,1100,250,323,3700,1100,250,324,3700,1100,250,325,3700,1100,250,326,3700,1100,250,327,3700,1100,250,328,3700,1100,250,329,3700,1100,250,330,3700,1100,250,331,3700,1100,250,332,3700,1100,250,333,3700,1100,250,334,3700,1100,250,335,3700,1100,250,336,3700,1100,250,337,3700,1100,250,338,3700,1100,250,339,3700,1100,250,340,3700,1100,250,341,3700,1100,250,342,3700,1100,250,343,3700,1100,250,344,3700,1100,250,345,3700,1100,250,346,3700,1100,250,347,3700,1100,250,348,3700,1100,250,349,3700,1100,250,350,3700,1100,250,351,3700,1100,250,352,3700,1100,250,353,3700,1100,250,354,3700,1100,250,355,3700,1100,250,356,3700,1100,250,357,3700,1100,250,358,3700,1100,250,359,3700,1100,250,360,3700,1100,250,361,3700,1100,250,362,3700,1100,250,363,3700,1100,250,364,3700,1100,250,365,3700,1100,250,366,3700,1100,250,367,3700,1100,250,368,3700,1100,250,369,3700,1100,250,370,3700,1100,250,371,3700,1100,250,372,3700,1100,250,373,3700,1100,250,374,3700,1100,250,375,3700,1100,250,376,3700,1100,250,377,3700,1100,250,378,3700,1100,250,379,3700,1100,250,380,3700,1100,250,381,3700,1100,250,382,3700,1100,250,383,3700,1100,250,384,3700,1100,250,385,3700,1100,250,386,3700,1100,250,387,3700,1100,250,388,3700,1100,250,389,3700,1100,250,390,3700,1100,250,391,3700,1100,250,392,3700,1100,250,393,3700,1100,250,394,3700,1100,250,395,3700,1100,250,396,3700,1100,250,397,3700,1100,250,398,3700,1100,250,399,3700,1100,250,400,3700,1100,250,401,3700,1100,250,402,3700,1100,250,403,3700,1100,250,404,3700,1100,250,405,3700,1100,250,406,3700,1100,250,407,3700,1100,250,408,3700,1100,250,409,3700,1100,250,410,3700,1100,250,411,3700,1100,250,412,3700,1100,250,413,3700,1100,250,414,3700,1100,250,415,3700,1100,250,416,3700,1100,250,417,3700,1100,250,418,3700,1100,250,419,3700,1100,250,420,3700,1100,250,421,3700,1100,250,422,3700,1100,250,423,3700,1100,250,424,3700,1100,250,425,3700,1100,250,426,3700,1100,250,427,3700,1100,250,428,3700,1100,250,429,3700,1100,250,430,3700,1100,250,431,3700,1100,250,432,3700,1100,250,433,3700,1100,250,434,3700,1100,250,435,3700,1100,250,436,3700,1100,250,437,3700,1100,250,438,3700,1100,250,439,3700,1100,250,440,3700,1100,250,441,3700,1100,250,442,3700,1100,250,443,3700,1100,250,444,3700,1100,250,445,3700,1100,250,446,3700,1100,250,447,3700,1100,250,448,3700,1100,250,449,3700,1100,250,450,3700,1100,250,451,3700,1100,250,452,3700,1100,250,453,3700,1100,250,454,3700,1100,250,455,3700,1100,250,456,3700,1100,250,457,3700,1100,250,458,3700,1100,250,459,3700,1100,250,460,3700
	,1100,250,461,3700,1100,250,462,3700,1100,250,463,3700,1100,250,464,3700,1100,250,465,3700,1100,250,466,3700,1100,250,467,3700,1100,250,468,3700,1100,250,469,3700,1100,250,470,3700,1100,250,471,3700,1100,250,472,3700,1100,250,473,3700,1100,250,474,3700,1100,250,475,3700,1100,250,476,3700,1100,250,477,3700,1100,250,478,3700,1100,250,479,3700,1100,250,480,3700,1100,250,481,3700,1100,250,482,3700,1100,250,483,3700,1100,250,484,3700,1100,250,485,3700,1100,250,486,3700,1100,250,487,3700,1100,250,488,3700,1100,250,489,3700,1100,250,490,3700,1100,250,491,3700,1100,250,492,3700,1100,250,493,3700,1100,250,494,3700,1100,250,495,3700,1100,250,496,3700,1100,250,497,3700,1100,250,498,3700,1100,250,499,3700,1100,250,500,3700,1100,250,501,3700,1100,250,502,3700,1100,250,503,3700,1100,250,504,3700,1100,250,505,3700,1100,250,506,3700,1100,250,507,3700,1100,250,508,3700,1100,250,509,3700,1100,250,510,3700,1100,250,511,3700,1100,250,512,3700,1100,250,513,3700,1100,250,514,3700,1100,250,515,3700,1100,250,516,3700,1100,250,517,3700,1100,250,518,3700,1100,250,519,3700,1100,250,520,3700,1100,250,521,3700,1100,250,522,3700,1100,250,523,3700,1100,250,524,3700,1100,250,525,3700,1100,250,526,3700,1100,250,527,3700,1100,250,528,3700,1100,250,529,3700,1100,250,530,3700,1100,250,531,3700,1100,250,532,3700,1100,250,533,3700,1100,250,534,3700,1100,250,535,3700,1100,250,536,3700,1100,250,537,3700,1100,250,538,3700,1100,250,539,3700,1100,250,540,3700,1100,250,541,3700,1100,250,542,3700,1100,250,543,3700,1100,250,544,3700,1100,250,545,3700,1100,250,546,3700,1100,250,547,3700,1100,250,548,3700,1100,250,549,3700,1100,250,550,3700,1100,250,551,3700,1100,250,552,3700,1100,250,553,3700,1100,250,554,3700,1100,250,555,3700,1100,250,556,3700,1100,250,557,3700,1100,250,558,3700,1100,250,559,3700,1100,250,560,3700,1100,250,561,3700,1100,250,562,3700,1100,250,563,3700,1100,250,564,3700,1100,250,565,3700,1100,250,566,3700,1100,250,567,3700,1100,250,568,3700,1100,250,569,3700,1100,250,570,3700,1100,250,571,3700,1100,250,572,3700,1100,250,573,3700,1100,250,574,3700,1100,250,575,3700,1100,250,576,3700,1100,250,577,3700,1100,250,578,3700,1100,250,579,3700,1100,250,580,3700,1100,250,581,3700,1100,250,582,3700,1100,250,583,3700,1100,250,584,3700,1100,250,585,3700,1100,250,586,3700,1100,250,587,3700,1100,250,588,3700,1100,250,589,3700,1100,250,590,3700,1100,250,591,3700,1100,250,592,3700,1100,250,593,3700,1100,250,594,3700,1100,250,595,3700,1100,250,596,3700,1100,250,597,3700,1100,250,598,3700,1100,250,599,3700,1100,250,600,3700,1100,250,601,3700,1100,250,602,3700,1100,250,603,3700,1100,250,604,3700,1100,250,605,3700,1100,250,606,3700,1100,250,607,3700,1100,250,608,3700,1100,250,609,3700,1100,250,610,3700,1100,250,611,3700,1100,250,612,3700,1100,250,613,3700,1100,250,614,3700,1100,250,615,3700,1100,250,616,3700,1100,250,617,3700,1100,250,618,3700,1100,250,619,3700,1100,250,620,3700,1100,250,621,3700,1100,250,622,3700,1100,250,623,3700,1100,250,624,3700,1100,250,625,3700,1100,250,626,3700,1100,250,627,3700,1100,250,628,3700,1100,250,629,3700,1100,250,630,3700,1100,250,631,3700,1100,250,632,3700,1100,250,633,3700,1100,250,634,3700,1100,250,635,3700,1100,250,636,3700,1100,250,637,3700,1100,250,638,3700,1100,250,639,3700,1100,250,640,3700,1100,250,641,3700,1100,250,642,3700,1100,250,643,3700,1100,250,644,3700,1100,250,645,3700,1100,250,646,3700,1100,250,647,3700,1100,250,648,3700,1100,250,649,3700,1100,250,650,3700,1100,250,651,3700,1100,250,652,3700,1100,250,653,3700,1100,250,654,3700,1100,250,655,3700,1100,250,656,3700,1100,250,657,3700,1100,250,658,3700,1100,250,659,3700,1100,250,660,3700,1100,250,661,3700,1100,250,662,3700,1100,250,663,3700,1100,250,664,3700,1100,250,665,3700,1100,250,666,3700,1100,250,667,3700,1100,250,668,3700,1100,250,669,3700,1100,250,670,3700,1100,250,671,3700,1100,250,672,3700,1100,250,673,3700,1100,250,674,3700,1100,250,675,3700,1100,250,676,3700,1100,250,677,3700,1100,250,678,3700,1100,250,679,3700,1100,250,680,3700,1100,250,681,3700,1100,250,682,3700,1100,250,683,3700,1100,250,684,3700,1100,250,685,3700,1100,250,686,3700,1100,250,687,3700,
	1100,250,688,3700,1100,250,689,3700,1100,250,690,3700,1100,250,691,3700,1100,250,692,3700,1100,250,693,3700,1100,250,694,3700,1100,250,695,3700,1100,250,696,3700,1100,250,697,3700,1100,250,698,3700,1100,250,699,3700,1100,250,700,3700,1100,250,701,3700,1100,250,702,3700,1100,250,703,3700,1100,250,704,3700,1100,250,705,3700,1100,250,706,3700,1100,250,707,3700,1100,250,708,3700,1100,250,709,3700,1100,250,710,3700,1100,250,711,3700,1100,250,712,3700,1100,250,713,3700,1100,250,714,3700,1100,250,715,3700,1100,250,716,3700,1100,250,717,3700,1100,250,718,3700,1100,250,719,3700,1100,250,720,3700,1100,250,721,3700,1100,250,722,3700,1100,250,723,3700,1100,250,724,3700,1100,250,725,3700,1100,250,726,3700,1100,250,727,3700,1100,250,728,3700,1100,250,729,3700,1100,250,730,3700,1100,250,731,3700,1100,250,732,3700,1100,250,733,3700,1100,250,734,3700,1100,250,735,3700,1100,250,736,3700,1100,250,737,3700,1100,250,738,3700,1100,250,739,3700,1100,250,740,3700,1100,250,741,3700,1100,250,742,3700,1100,250,743,3700,1100,250,744,3700,1100,250,745,3700,1100,250,746,3700,1100,250,747,3700,1100,250,748,3700,1100,250,749,3700,1100,250,750,3700,1100,250,751,3700,1100,250,752,3700,1100,250,753,3700,1100,250,754,3700,1100,250,755,3700,1100,250,756,3700,1100,250,757,3700,1100,250,758,3700,1100,250,759,3700,1100,250,760,3700,1100,250,761,3700,1100,250,762,3700,1100,250,763,3700,1100,250,764,3700,1100,250,765,3700,1100,250,766,3700,1100,250,767,3700,1100,250,
};

static u16 GuitarTestPlatformINI[TOTAL_PIXEL_NUM*4]=
{
	0,8000,10,500,1,8000,10,500,2,8000,10,500,3,8000,10,500,4,8000,10,500,5,8000,10,500,6,8000,10,500,7,8000,10,500,8,8000,10,500,9,8000,10,500,10,8000,10,500,11,8000,10,500,12,8000,10,500,13,8000,10,500,14,8000,10,500,15,8000,10,500,16,8000,10,500,17,8000,10,500,18,8000,10,500,19,8000,10,500,20,8000,10,500,21,8000,10,500,22,8000,10,500,23,8000,10,500,24,8000,10,500,25,8000,10,500,26,8000,10,500,27,8000,10,500,28,8000,10,500,29,8000,10,500,30,8000,10,500,31,8000,10,500,32,8000,10,500,33,8000,10,500,34,8000,10,500,35,8000,10,500,36,8000,10,500,37,8000,10,500,38,8000,10,500,39,8000,10,500,40,8000,10,500,41,8000,10,500,42,8000,10,500,43,8000,10,500,44,8000,10,500,45,8000,10,500,46,8000,10,500,47,8000,10,500,48,8000,10,500,49,8000,10,500,50,8000,10,500,51,8000,10,500,52,8000,10,500,53,8000,10,500,54,8000,10,500,55,8000,10,500,56,8000,10,500,57,8000,10,500,58,8000,10,500,59,8000,10,500,60,8000,10,500,61,8000,10,500,62,8000,10,500,63,8000,10,500,64,8000,10,500,65,8000,10,500,66,8000,10,500,67,8000,10,500,68,8000,10,500,69,8000,10,500,70,8000,10,500,71,8000,10,500,72,8000,10,500,73,8000,10,500,74,8000,10,500,75,8000,10,500,76,8000,10,500,77,8000,10,500,78,8000,10,500,79,8000,10,500,80,8000,10,500,81,8000,10,500,82,8000,10,500,83,8000,10,500,84,8000,10,500,85,8000,10,500,86,8000,10,500,87,8000,10,500,88,8000,10,500,89,8000,10,500,90,8000,10,500,91,8000,10,500,92,8000,10,500,93,8000,10,500,94,8000,10,500,95,8000,10,500,96,8000,10,500,97,8000,10,500,98,8000,10,500,99,8000,10,500,100,8000,10,500,101,8000,10,500,102,8000,10,500,103,8000,10,500,104,8000,10,500,105,8000,10,500,106,8000,10,500,107,8000,10,500,108,8000,10,500,109,8000,10,500,110,8000,10,500,111,8000,10,500,112,8000,10,500,113,8000,10,500,114,8000,10,500,115,8000,10,500,116,8000,10,500,117,8000,10,500,118,8000,10,500,119,8000,10,500,120,8000,10,500,121,8000,10,500,122,8000,10,500,123,8000,10,500,124,8000,10,500,125,8000,10,500,126,8000,10,500,127,8000,10,500,128,8000,10,500,129,8000,10,500,130,8000,10,500,131,8000,10,500,132,8000,10,500,133,8000,10,500,134,8000,10,500,135,8000,10,500,136,8000,10,500,137,8000,10,500,138,8000,10,500,139,8000,10,500,140,8000,10,500,141,8000,10,500,142,8000,10,500,143,8000,10,500,144,8000,10,500,145,8000,10,500,146,8000,10,500,147,8000,10,500,148,8000,10,500,149,8000,10,500,150,8000,10,500,151,8000,10,500,152,8000,10,500,153,8000,10,500,154,8000,10,500,155,8000,10,500,156,8000,10,500,157,8000,10,500,158,8000,10,500,159,8000,10,500,160,8000,10,500,161,8000,10,500,162,8000,10,500,163,8000,10,500,164,8000,10,500,165,8000,10,500,166,8000,10,500,167,8000,10,500,168,8000,10,500,169,8000,10,500,170,8000,10,500,171,8000,10,500,172,8000,10,500,173,8000,10,500,174,8000,10,500,175,8000,10,500,176,8000,10,500,177,8000,10,500,178,8000,10,500,179,8000,10,500,180,8000,10,500,181,8000,10,500,182,8000,10,500,183,8000,10,500,184,8000,10,500,185,8000,10,500,186,8000,10,500,187,8000,10,500,188,8000,10,500,189,8000,10,500,190,8000,10,500,191,8000,10,500,192,8000,10,500,193,8000,10,500,194,8000,10,500,195,8000,10,500,196,8000,10,500,197,8000,10,500,198,8000,10,500,199,8000,10,500,200,8000,10,500,201,8000,10,500,202,8000,10,500,203,8000,10,500,204,8000,10,500,205,8000,10,500,206,8000,10,500,207,8000,10,500,208,8000,10,500,209,8000,10,500,210,8000,10,500,211,8000,10,500,212,8000,10,500,213,8000,10,500,214,8000,10,500,215,8000,10,500,216,8000,10,500,217,8000,10,500,218,8000,10,500,219,8000,10,500,220,8000,10,500,221,8000,10,500,222,8000,10,500,223,8000,10,500,224,8000,10,500,225,8000,10,500,226,8000,10,500,227,8000,10,500,228,8000,10,500,229,8000,10,500,230,8000,10,500,231,8000,10,500,232,8000,10,500,233,8000,10,500,234,8000,10,500,235,8000,10,500,236,8000,10,500,237,8000,10,500,238,8000,10,500,239,8000,10,500,240,8000,10,500,241,8000,10,500,242,8000,10,500,243,8000,10,500,244,8000,10,500,245,8000,10,500,246,8000,10,500,247,8000,10,500,248,8000,10,500,249,8000,10,500,250,8000,10,500,251,8000,10,500,252,8000,10,500,253,8000,10,500,254,8000,10,500,255,8000,10,500,256,8000,10,500,257,8000,10,500,258,8000,10,500,259,8000,10,500,260,8000,10,500,261,8000,10,500,262,8000
	,10,500,263,8000,10,500,264,8000,10,500,265,8000,10,500,266,8000,10,500,267,8000,10,500,268,8000,10,500,269,8000,10,500,270,8000,10,500,271,8000,10,500,272,8000,10,500,273,8000,10,500,274,8000,10,500,275,8000,10,500,276,8000,10,500,277,8000,10,500,278,8000,10,500,279,8000,10,500,280,8000,10,500,281,8000,10,500,282,8000,10,500,283,8000,10,500,284,8000,10,500,285,8000,10,500,286,8000,10,500,287,8000,10,500,288,8000,10,500,289,8000,10,500,290,8000,10,500,291,8000,10,500,292,8000,10,500,293,8000,10,500,294,8000,10,500,295,8000,10,500,296,8000,10,500,297,8000,10,500,298,8000,10,500,299,8000,10,500,300,8000,10,500,301,8000,10,500,302,8000,10,500,303,8000,10,500,304,8000,10,500,305,8000,10,500,306,8000,10,500,307,8000,10,500,308,8000,10,500,309,8000,10,500,310,8000,10,500,311,8000,10,500,312,8000,10,500,313,8000,10,500,314,8000,10,500,315,8000,10,500,316,8000,10,500,317,8000,10,500,318,8000,10,500,319,8000,10,500,320,8000,10,500,321,8000,10,500,322,8000,10,500,323,8000,10,500,324,8000,10,500,325,8000,10,500,326,8000,10,500,327,8000,10,500,328,8000,10,500,329,8000,10,500,330,8000,10,500,331,8000,10,500,332,8000,10,500,333,8000,10,500,334,8000,10,500,335,8000,10,500,336,8000,10,500,337,8000,10,500,338,8000,10,500,339,8000,10,500,340,8000,10,500,341,8000,10,500,342,8000,10,500,343,8000,10,500,344,8000,10,500,345,8000,10,500,346,8000,10,500,347,8000,10,500,348,8000,10,500,349,8000,10,500,350,8000,10,500,351,8000,10,500,352,8000,10,500,353,8000,10,500,354,8000,10,500,355,8000,10,500,356,8000,10,500,357,8000,10,500,358,8000,10,500,359,8000,10,500,360,8000,10,500,361,8000,10,500,362,8000,10,500,363,8000,10,500,364,8000,10,500,365,8000,10,500,366,8000,10,500,367,8000,10,500,368,8000,10,500,369,8000,10,500,370,8000,10,500,371,8000,10,500,372,8000,10,500,373,8000,10,500,374,8000,10,500,375,8000,10,500,376,8000,10,500,377,8000,10,500,378,8000,10,500,379,8000,10,500,380,8000,10,500,381,8000,10,500,382,8000,10,500,383,8000,10,500,384,8000,10,500,385,8000,10,500,386,8000,10,500,387,8000,10,500,388,8000,10,500,389,8000,10,500,390,8000,10,500,391,8000,10,500,392,8000,10,500,393,8000,10,500,394,8000,10,500,395,8000,10,500,396,8000,10,500,397,8000,10,500,398,8000,10,500,399,8000,10,500,400,8000,10,500,401,8000,10,500,402,8000,10,500,403,8000,10,500,404,8000,10,500,405,8000,10,500,406,8000,10,500,407,8000,10,500,408,8000,10,500,409,8000,10,500,410,8000,10,500,411,8000,10,500,412,8000,10,500,413,8000,10,500,414,8000,10,500,415,8000,10,500,416,8000,10,500,417,8000,10,500,418,8000,10,500,419,8000,10,500,420,8000,10,500,421,8000,10,500,422,8000,10,500,423,8000,10,500,424,8000,10,500,425,8000,10,500,426,8000,10,500,427,8000,10,500,428,8000,10,500,429,8000,10,500,430,8000,10,500,431,8000,10,500,432,8000,10,500,433,8000,10,500,434,8000,10,500,435,8000,10,500,436,8000,10,500,437,8000,10,500,438,8000,10,500,439,8000,10,500,440,8000,10,500,441,8000,10,500,442,8000,10,500,443,8000,10,500,444,8000,10,500,445,8000,10,500,446,8000,10,500,447,8000,10,500,448,8000,10,500,449,8000,10,500,450,8000,10,500,451,8000,10,500,452,8000,10,500,453,8000,10,500,454,8000,10,500,455,8000,10,500,456,8000,10,500,457,8000,10,500,458,8000,10,500,459,8000,10,500,460,8000,10,500,461,8000,10,500,462,8000,10,500,463,8000,10,500,464,8000,10,500,465,8000,10,500,466,8000,10,500,467,8000,10,500,468,8000,10,500,469,8000,10,500,470,8000,10,500,471,8000,10,500,472,8000,10,500,473,8000,10,500,474,8000,10,500,475,8000,10,500,476,8000,10,500,477,8000,10,500,478,8000,10,500,479,8000,10,500,480,8000,10,500,481,8000,10,500,482,8000,10,500,483,8000,10,500,484,8000,10,500,485,8000,10,500,486,8000,10,500,487,8000,10,500,488,8000,10,500,489,8000,10,500,490,8000,10,500,491,8000,10,500,492,8000,10,500,493,8000,10,500,494,8000,10,500,495,8000,10,500,496,8000,10,500,497,8000,10,500,498,8000,10,500,499,8000,10,500,500,8000,10,500,501,8000,10,500,502,8000,10,500,503,8000,10,500,504,8000,10,500,505,8000,10,500,506,8000,10,500,507,8000,10,500,508,8000,10,500,509,8000,10,500,510,8000,10,500,511,8000,10,500,512,8000,10,500,513,8000,10,500,514,8000,10,500,515,8000,10,500,516,8000,10,500,517,8000,10,500,
	518,8000,10,500,519,8000,10,500,520,8000,10,500,521,8000,10,500,522,8000,10,500,523,8000,10,500,524,8000,10,500,525,8000,10,500,526,8000,10,500,527,8000,10,500,528,8000,10,500,529,8000,10,500,530,8000,10,500,531,8000,10,500,532,8000,10,500,533,8000,10,500,534,8000,10,500,535,8000,10,500,536,8000,10,500,537,8000,10,500,538,8000,10,500,539,8000,10,500,540,8000,10,500,541,8000,10,500,542,8000,10,500,543,8000,10,500,544,8000,10,500,545,8000,10,500,546,8000,10,500,547,8000,10,500,548,8000,10,500,549,8000,10,500,550,8000,10,500,551,8000,10,500,552,8000,10,500,553,8000,10,500,554,8000,10,500,555,8000,10,500,556,8000,10,500,557,8000,10,500,558,8000,10,500,559,8000,10,500,560,8000,10,500,561,8000,10,500,562,8000,10,500,563,8000,10,500,564,8000,10,500,565,8000,10,500,566,8000,10,500,567,8000,10,500,568,8000,10,500,569,8000,10,500,570,8000,10,500,571,8000,10,500,572,8000,10,500,573,8000,10,500,574,8000,10,500,575,8000,10,500,576,8000,10,500,577,8000,10,500,578,8000,10,500,579,8000,10,500,580,8000,10,500,581,8000,10,500,582,8000,10,500,583,8000,10,500,584,8000,10,500,585,8000,10,500,586,8000,10,500,587,8000,10,500,588,8000,10,500,589,8000,10,500,590,8000,10,500,591,8000,10,500,592,8000,10,500,593,8000,10,500,594,8000,10,500,595,8000,10,500,596,8000,10,500,597,8000,10,500,598,8000,10,500,599,8000,10,500,600,8000,10,500,601,8000,10,500,602,8000,10,500,603,8000,10,500,604,8000,10,500,605,8000,10,500,606,8000,10,500,607,8000,10,500,608,8000,10,500,609,8000,10,500,610,8000,10,500,611,8000,10,500,612,8000,10,500,613,8000,10,500,614,8000,10,500,615,8000,10,500,616,8000,10,500,617,8000,10,500,618,8000,10,500,619,8000,10,500,620,8000,10,500,621,8000,10,500,622,8000,10,500,623,8000,10,500,624,8000,10,500,625,8000,10,500,626,8000,10,500,627,8000,10,500,628,8000,10,500,629,8000,10,500,630,8000,10,500,631,8000,10,500,632,8000,10,500,633,8000,10,500,634,8000,10,500,635,8000,10,500,636,8000,10,500,637,8000,10,500,638,8000,10,500,639,8000,10,500,640,8000,10,500,641,8000,10,500,642,8000,10,500,643,8000,10,500,644,8000,10,500,645,8000,10,500,646,8000,10,500,647,8000,10,500,648,8000,10,500,649,8000,10,500,650,8000,10,500,651,8000,10,500,652,8000,10,500,653,8000,10,500,654,8000,10,500,655,8000,10,500,656,8000,10,500,657,8000,10,500,658,8000,10,500,659,8000,10,500,660,8000,10,500,661,8000,10,500,662,8000,10,500,663,8000,10,500,664,8000,10,500,665,8000,10,500,666,8000,10,500,667,8000,10,500,668,8000,10,500,669,8000,10,500,670,8000,10,500,671,8000,10,500,672,8000,10,500,673,8000,10,500,674,8000,10,500,675,8000,10,500,676,8000,10,500,677,8000,10,500,678,8000,10,500,679,8000,10,500,680,8000,10,500,681,8000,10,500,682,8000,10,500,683,8000,10,500,684,8000,10,500,685,8000,10,500,686,8000,10,500,687,8000,10,500,688,8000,10,500,689,8000,10,500,690,8000,10,500,691,8000,10,500,692,8000,10,500,693,8000,10,500,694,8000,10,500,695,8000,10,500,696,8000,10,500,697,8000,10,500,698,8000,10,500,699,8000,10,500,700,8000,10,500,701,8000,10,500,702,8000,10,500,703,8000,10,500,704,8000,10,500,705,8000,10,500,706,8000,10,500,707,8000,10,500,708,8000,10,500,709,8000,10,500,710,8000,10,500,711,8000,10,500,712,8000,10,500,713,8000,10,500,714,8000,10,500,715,8000,10,500,716,8000,10,500,717,8000,10,500,718,8000,10,500,719,8000,10,500,720,8000,10,500,721,8000,10,500,722,8000,10,500,723,8000,10,500,724,8000,10,500,725,8000,10,500,726,8000,10,500,727,8000,10,500,728,8000,10,500,729,8000,10,500,730,8000,10,500,731,8000,10,500,732,8000,10,500,733,8000,10,500,734,8000,10,500,735,8000,10,500,736,8000,10,500,737,8000,10,500,738,8000,10,500,739,8000,10,500,740,8000,10,500,741,8000,10,500,742,8000,10,500,743,8000,10,500,744,8000,10,500,745,8000,10,500,746,8000,10,500,747,8000,10,500,748,8000,10,500,749,8000,10,500,750,8000,10,500,751,8000,10,500,752,8000,10,500,753,8000,10,500,754,8000,10,500,755,8000,10,500,756,8000,10,500,757,8000,10,500,758,8000,10,500,759,8000,10,500,760,8000,10,500,761,8000,10,500,762,8000,10,500,763,8000,10,500,764,8000,10,500,765,8000,10,500,766,8000,10,500,767,8000,10,500,
};


static bool AbsoluteTotalCheck = true;
static bool AreaAccordCheck = false;
static u16 TotalMaxValue = 5500;
static u16 TotalMinValue = 1500;
static u16 TotalMaxValue_GIS = 4000;
static u16 TotalMinValue_GIS = 1500;
static u16 TotalMaxValue_TopTouch = 5500;
static u16 TotalMinValue_TopTouch = 1500;
static s32 test_result=FAIL;

extern int gt928_debug;
// add by leo for dynamic change limit value --

s32 gt9xx_short_parse_cfg(void)
{
	u8 i = 0;
	u8 drv_num = 0, sen_num = 0;

	u8 config[256] = {(u8)(GTP_REG_CONFIG_DATA >> 8), (u8)GTP_REG_CONFIG_DATA, 0};

	if (gtp_i2c_read(i2c_connect_client, config, GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH) <= 0)
	{
		SET_INFO_LINE_ERR("Failed to read config!");
		return FAIL;
	}

	drv_num = (config[GTP_ADDR_LENGTH + GT9_REG_SEN_DRV_CNT-GT9_REG_CFG_BEG] & 0x1F)
	          + (config[GTP_ADDR_LENGTH + GT9_REG_SEN_DRV_CNT+1 -GT9_REG_CFG_BEG] & 0x1F);
	sen_num = (config[GTP_ADDR_LENGTH + GT9_REG_SEN_DRV_CNT+2-GT9_REG_CFG_BEG] & 0x0F)
	          + ((config[GTP_ADDR_LENGTH + GT9_REG_SEN_DRV_CNT+2-GT9_REG_CFG_BEG]>>4) & 0x0F);

	if (drv_num < MIN_DRIVER_NUM || drv_num > MAX_DRIVER_NUM)
	{
		GTP_ERROR("driver number error!");
		return FAIL;
	}
	if (sen_num < MIN_SENSOR_NUM || sen_num > MAX_SENSOR_NUM)
	{
		GTP_ERROR("sensor number error!");
		return FAIL;
	}
	// get sensor and driver order
	memset(cfg_sen_order, 0xFF, MAX_SENSOR_NUM);
	for (i = 0; i < sen_num; ++i)
	{
		cfg_sen_order[i] = config[GTP_ADDR_LENGTH + GT9_REG_SEN_ORD - GT9_REG_CFG_BEG + i];
	}

	memset(cfg_drv_order, 0xFF, MAX_DRIVER_NUM);
	for (i = 0; i < drv_num; ++i)
	{
		cfg_drv_order[i] = config[GTP_ADDR_LENGTH + GT9_REG_DRV_ORD - GT9_REG_CFG_BEG + i];
	}

	return SUCCESS;
}

/*
 * @param:
 *      phy_chnl: ic detected short channel, is_driver: it's driver or not
 * @Return:
 *      0xff: the ic channel is not used, otherwise: the tp short channel
 */
u8 gt9_get_short_tp_chnl(u8 phy_chnl, u8 is_driver)
{
	u8 i = 0;
	if (is_driver)
	{
		for (i = 0; i < MAX_DRIVER_NUM; ++i)
		{
			if (cfg_drv_order[i] == phy_chnl)
			{
				return i;
			}
			else if (cfg_drv_order[i] == 0xff)
			{
				return 0xff;
			}
		}
	}
	else
	{
		for (i = 0; i < MAX_SENSOR_NUM; ++i)
		{
			if (cfg_sen_order[i] == phy_chnl)
			{
				return i;
			}
			else if (cfg_sen_order[i] == 0xff)
			{
				return 0xff;
			}
		}
	}
	return 0xff;
}


u8 gt9xx_set_ic_msg(struct i2c_client *client, u16 addr, u8 val)
{
	s32 i = 0;
	u8 msg[3];

	msg[0] = (addr >> 8) & 0xff;
	msg[1] = addr & 0xff;
	msg[2] = val;

	for (i = 0; i < 5; i++)
	{
		if (gtp_i2c_write(client, msg, GTP_ADDR_LENGTH + 1) > 0)
		{
			break;
		}
	}

	if (i >= 5)
	{
		GTP_ERROR("Set data to 0x%02x%02x failed!", msg[0], msg[1]);
		return FAIL;
	}

	return SUCCESS;
}

static s32 gtp_i2c_end_cmd(struct i2c_client *client)
{
	u8  end_cmd[3] = {GTP_READ_COOR_ADDR >> 8, GTP_READ_COOR_ADDR & 0xFF, 0};
	s32 ret = 0;

	ret = gtp_i2c_write(client, end_cmd, 3);
	if (ret < 0)
	{
		SET_INFO_LINE_INFO("I2C write end_cmd  error!");
	}
	return ret;
}

s32 gtp_parse_config(void)
{
#if GTP_HAVE_TOUCH_KEY
	u8 i = 0;
	u8 key_pos = 0;
#endif
	int j = 0;
	struct goodix_ts_data *ts;
	u8 chksum = 0;
	u8 config[256] = {(u8)(GTP_REG_CONFIG_DATA >> 8), (u8)GTP_REG_CONFIG_DATA, 0};

	if (gtp_i2c_read(i2c_connect_client, config, GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH) <= 0)
	{
		SET_INFO_LINE_ERR("Failed to read config!");
		return FAIL;
	}
	// disable hopping
	if (config[GTP_ADDR_LENGTH + 0x807D - GTP_REG_CONFIG_DATA] & 0x80)
	{
		GTP_INFO("Disable hopping"); // add by leo
		config[GTP_ADDR_LENGTH + 0x807D - GTP_REG_CONFIG_DATA] &= 0x7F;
		ts = i2c_get_clientdata(i2c_connect_client);
		// calculate checksum
		for (j = 0; j < (ts->gtp_cfg_len-2); ++j)
		{
			chksum += config[GTP_ADDR_LENGTH + j];
		}
		config[ts->gtp_cfg_len] = (~chksum) + 1;
		config[ts->gtp_cfg_len+1] = 0x01;

		gtp_i2c_write(i2c_connect_client, config, GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH);
	}

	gt9xx_drv_num = (config[GTP_ADDR_LENGTH + GT9_REG_SEN_DRV_CNT-GT9_REG_CFG_BEG] & 0x1F)
	                + (config[GTP_ADDR_LENGTH + GT9_REG_SEN_DRV_CNT+1 -GT9_REG_CFG_BEG] & 0x1F);
	gt9xx_sen_num = (config[GTP_ADDR_LENGTH + GT9_REG_SEN_DRV_CNT+2-GT9_REG_CFG_BEG] & 0x0F)
	                + ((config[GTP_ADDR_LENGTH + GT9_REG_SEN_DRV_CNT+2-GT9_REG_CFG_BEG]>>4) & 0x0F);

	GTP_INFO("gt9xx_drv_num = %d",gt9xx_drv_num); // add by leo
	GTP_INFO("gt9xx_sen_num = %d",gt9xx_sen_num); //add by leo

	if (gt9xx_drv_num < MIN_DRIVER_NUM || gt9xx_drv_num > MAX_DRIVER_NUM)
	{
		SET_INFO_LINE_ERR("driver number error!");
		return FAIL;
	}
	if (gt9xx_sen_num < MIN_SENSOR_NUM || gt9xx_sen_num > MAX_SENSOR_NUM)
	{
		SET_INFO_LINE_ERR("sensor number error!");
		return FAIL;
	}
	gt9xx_sc_pxl_cnt = gt9xx_pixel_cnt = gt9xx_drv_num * gt9xx_sen_num;

	GTP_INFO("gt9xx_sc_pxl_cnt = gt9xx_pixel_cnt = %d",gt9xx_sc_pxl_cnt); //add by leo if device with key then gt9xx_sc_pxl_cnt = gt9xx_pixel_cnt -1

#if GTP_HAVE_TOUCH_KEY
	gt9xx_sc_drv_num = gt9xx_drv_num - (config[0x804E - GT9_REG_CFG_BEG + GTP_ADDR_LENGTH] & 0x01);

	key_is_isolated = 0;
	key_iso_pos[0] = 0;
	for (i = 0; i < 4; ++i)
	{
		key_pos = config[GTP_ADDR_LENGTH + GT9_REG_KEY_VAL - GT9_REG_CFG_BEG + i]%0x08;
		GTP_DEBUG("key_val[%d] = 0x%x", i+1, config[GTP_ADDR_LENGTH + GT9_REG_KEY_VAL - GT9_REG_CFG_BEG + i]);
		if (key_pos != 0)
		{
			break;
		}
		else
		{
			key_iso_pos[0]++;
			key_iso_pos[i+1] = config[GTP_ADDR_LENGTH + GT9_REG_KEY_VAL - GT9_REG_CFG_BEG + i]/8;
		}
	}
	if (i == 4)
	{
		key_is_isolated = 1;
	}
	gt9xx_sc_pxl_cnt = gt9xx_pixel_cnt - (gt9xx_drv_num-gt9xx_sc_drv_num) * gt9xx_sen_num;
	GTP_DEBUG("drv num: %d, sen num: %d, sc drv num: %d", gt9xx_drv_num, gt9xx_sen_num, gt9xx_sc_drv_num);
	if (key_is_isolated)
	{
		GTP_DEBUG("[%d key(s)]: %d, %d, %d, %d", key_iso_pos[0], key_iso_pos[1], key_iso_pos[2], key_iso_pos[3], key_iso_pos[4]);
	}
#endif

	return SUCCESS;
}



/*
 * Function:
 * 		write one byte to specified register
 * Input:
 * 		reg: the register address
 * 		val: the value to write into
 * Return:
 * 		i2c_write function return
 */
s32 gtp_write_register(struct i2c_client * client, u16 reg, u8 val)
{
	u8 buf[3];
	buf[0] = (u8) (reg >> 8);
	buf[1] = (u8) reg;
	buf[2] = val;
	return gtp_i2c_write(client, buf, 3);
}
/*
 * Function:
 * 		read one byte from specified register into buf
 * Input:
 *		reg: the register
 * 		buf: the buffer for one byte
 * Return:
 *		i2c_read function return
 */
s32 gtp_read_register(struct i2c_client * client, u16 reg, u8* buf)
{
	buf[0] = (u8)(reg >> 8);
	buf[1] = (u8)reg;
	return gtp_i2c_read(client, buf, 3);
}

/*
 * Function:
 * 		burn dsp_short code
 * Input:
 * 		i2c_client
 * Return:
 * 		SUCCESS: burning succeed, FAIL: burning failed
 */
s32 gtp_burn_dsp_short(struct i2c_client *client)
{
	s32 ret = 0;
	u8 *opr_buf;
	u16 i = 0;
	u16 addr = GTP_REG_DSP_SHORT;
	u16 opr_len = 0;
	u16 left = 0;

	GTP_DEBUG("Start writing dsp_short code");
	opr_buf = (u8*)kmalloc(sizeof(u8) * (sizeof(dsp_short)+2), GFP_KERNEL);
	if (!opr_buf)
	{
		SET_INFO_LINE_ERR("failed to allocate memory for check buffer!");
		return FAIL;
	}

	left = sizeof(dsp_short);
	while (left > 0)
	{
		opr_buf[0] = (u8)(addr >> 8);
		opr_buf[1] = (u8)(addr);
		if (left > 2048)
		{
			opr_len = 2048;
		}
		else
		{
			opr_len = left;
		}
		memcpy(&opr_buf[2], &dsp_short[addr-GTP_REG_DSP_SHORT], opr_len);
		ret = gtp_i2c_write(client, opr_buf, 2 + opr_len);
		if ( ret < 0 )
		{
			SET_INFO_LINE_ERR("write dsp_short code failed!");
			return FAIL;
		}
		addr += opr_len;
		left -= opr_len;
	}

	// check code: 0xC000~0xCFFF
	GTP_DEBUG("Start checking dsp_short code");
	addr = GTP_REG_DSP_SHORT;
	left = sizeof(dsp_short);
	while (left > 0)
	{
		opr_buf[0] = (u8)(addr >> 8);
		opr_buf[1] = (u8)(addr);

		msleep(20);

		if (left > 2048)
		{
			opr_len = 2048;
		}
		else
		{
			opr_len = left;
		}

		ret = gtp_i2c_read(client, opr_buf, opr_len+2);
		if (ret < 0)
		{
			kfree(opr_buf);
			return FAIL;
		}
		for (i = 0; i < opr_len; ++i)
		{
#if 0
			if((i!=0)&&(i%16==0))
			{
				printk("\n");
			}
			printk("0x%02x ",opr_buf[i+2]);
#endif

			if (opr_buf[i+2] != dsp_short[addr-GTP_REG_DSP_SHORT+i])
			{
				SET_INFO_LINE_ERR("check dsp_short code failed!");
				//SET_INFO_LINE_ERR("opr_buf[%d] = 0x%02x, dsp_short[%d]",i+2,opr_buf[i+2],addr-GTP_REG_DSP_SHORT+i,dsp_short[addr-GTP_REG_DSP_SHORT+i]);
				kfree(opr_buf);
				return FAIL;
			}
		}
		addr += opr_len;
		left -= opr_len;
	}

	kfree(opr_buf);
	return SUCCESS;
}
/*
 * Function:
 * 		check the resistor between shortlike channels if less than threshold confirm as short
 * INPUT:
 *		Short like Information struct pointer
 * Returns:
 *		SUCCESS: it's shorted FAIL: otherwise
 */
s32 gtp_short_resist_check(struct gt9xx_short_info *short_node)
{
	s32 short_resist = 0;
	struct gt9xx_short_info *node = short_node;
	u8 master = node->master;
	u8 slave = node->slave;
	u8 chnnl_tx[4] = { GT9_DRV_HEAD|13, GT9_DRV_HEAD|28,
	                   GT9_DRV_HEAD|29, GT9_DRV_HEAD|42
	                 };
	s32 numberator = 0;
	u32 amplifier = 1000;  // amplify 1000 times to emulate float computing


	// Tx-ABIST & Tx_ABIST
	if ((((master > chnnl_tx[0]) && (master <= chnnl_tx[1])) &&
	        ((slave > chnnl_tx[0]) && (slave <= chnnl_tx[1])) ) ||
	        (((master > chnnl_tx[2]) && (master <= chnnl_tx[3])) &&
	         ((slave > chnnl_tx[2]) && (master <= chnnl_tx[3]))))
	{
		numberator = node->self_data * 40 * amplifier;
		short_resist = numberator/(node->short_code) - 40 * amplifier;
	}
	// Receiver is Rx-odd(1,3,5)
	else if ((node->slave & (GT9_DRV_HEAD | 0x01)) == 0x01)
	{
		numberator = node->self_data * 60 * amplifier;
		short_resist = numberator/node->short_code - 40 * amplifier;
	}
	else
	{
		numberator = node->self_data * 60 * amplifier;
		short_resist = numberator / node->short_code - 60 * amplifier;
	}
	GTP_DEBUG("self_data = %d" ,node->self_data);
	GTP_DEBUG("master = 0x%x, slave = 0x%x", node->master, node->slave);
	GTP_DEBUG("short_code = %d, short_resist = %d", node->short_code, short_resist);

	if (short_resist < 0)
	{
		short_resist = 0;
	}

	if (short_resist < (gt900_resistor_threshold * amplifier))
	{
		node->impedance = short_resist / amplifier;
		return SUCCESS;
	}
	else
	{
		return FAIL;
	}
}



/*
 * Function:
 * 		compute the result, whether there are shorts or not
 * Input:
 * 		i2c_client
 * Return:
 * 		SUCCESS
 */
s32 gtp_compute_rslt(struct i2c_client *client)
{
	u16 short_code;
	u8 i = 0, j = 0;
	u16 result_addr;
	u8 *result_buf;
	u16 *self_data;
	s32 ret = 0;
	u16 data_len = 3 + (MAX_DRIVER_NUM + MAX_SENSOR_NUM) * 2 + 2; // a short data frame length
	struct gt9xx_short_info short_node;
	u16 node_idx = 0; // short_sum index: 0~GT9_INFO_NODE_MAX

	u8 tx_short_num = 0;
	u8 rx_short_num = 0;

	u8 master, slave;

	self_data = (u16*)kmalloc(sizeof(u16) * ((MAX_DRIVER_NUM + MAX_SENSOR_NUM)), GFP_KERNEL);
	result_buf = (u8*)kmalloc(sizeof(u8) * (data_len+2), GFP_KERNEL);
	short_sum = (struct gt9xx_short_info *) kmalloc(sizeof(struct gt9xx_short_info) * GT9_INFO_NODE_MAX, GFP_KERNEL);

	if (!self_data || !result_buf || !short_sum)
	{
		SET_INFO_LINE_ERR("allocate memory for short result failed!");
		return FAIL;
	}

	// Get Selfdata
	result_buf[0] = 0xA4;
	result_buf[1] = 0xA1;
	gtp_i2c_read(client, result_buf, 2 + 144);
	for (i = 0, j = 0; i < 144; i += 2)
	{
		self_data[j++] = (u16)(result_buf[i] << 8) + (u16)(result_buf[i+1]);
	}
	GTP_DEBUG("Self Data:");
	GTP_DEBUG_ARRAY(result_buf+2, 144);


	// Get TxShortNum & RxShortNum
	result_buf[0] = 0x88;
	result_buf[1] = 0x02;
	gtp_i2c_read(client, result_buf, 2 + 2);
	tx_short_num = result_buf[2];
	rx_short_num = result_buf[3];

	GTP_DEBUG("Tx Short Num: %d, Rx Short Num: %d", tx_short_num, rx_short_num);

	//
	result_addr = 0x8860;
	data_len = 3 + (MAX_DRIVER_NUM + MAX_SENSOR_NUM) * 2 + 2;
	for (i = 0; i < tx_short_num; ++i)
	{
		result_buf[0] = (u8) (result_addr >> 8);
		result_buf[1] = (u8) (result_addr);
		ret = gtp_i2c_read(client, result_buf, data_len+2);
		if (ret < 0)
		{
			SET_INFO_LINE_ERR("read result data failed!");
		}
		GTP_DEBUG("Result Buffer: ");
		GTP_DEBUG_ARRAY(result_buf+2, data_len);

		short_node.master_is_driver = 1;
		short_node.master = result_buf[2];

		// Tx - Tx
		for (j = i + 1; j < MAX_DRIVER_NUM; ++j)
		{
			short_code = (result_buf[2+3+j*2] << 8) + result_buf[2+3+j*2+1];
			if (short_code > gt900_short_threshold)
			{
				short_node.slave_is_driver = 1;
				short_node.slave = ChannelPackage_TX[j] | GT9_DRV_HEAD;
				short_node.self_data = self_data[j];
				short_node.short_code = short_code;

				ret = gtp_short_resist_check(&short_node);
				if (ret == SUCCESS)
				{
					if (node_idx < GT9_INFO_NODE_MAX)
					{
						short_sum[node_idx++] = short_node;
					}
				}
			}
		}
		// Tx - Rx
		for (j = 0; j < MAX_SENSOR_NUM; ++j)
		{
			short_code = (result_buf[2+3+84+j*2] << 8) + result_buf[2+3+84+j*2+1];

			if (short_code > gt900_short_threshold)
			{
				short_node.slave_is_driver = 0;
				short_node.slave = j | GT9_SEN_HEAD;
				short_node.self_data = self_data[MAX_DRIVER_NUM + j];
				short_node.short_code = short_code;

				ret = gtp_short_resist_check(&short_node);
				if (ret == SUCCESS)
				{
					if (node_idx < GT9_INFO_NODE_MAX)
					{
						short_sum[node_idx++] = short_node;
					}
				}
			}
		}

		result_addr += data_len;
	}

	result_addr = 0xA0D2;
	data_len = 3 + MAX_SENSOR_NUM * 2 + 2;
	for (i = 0; i < rx_short_num; ++i)
	{
		result_buf[0] = (u8) (result_addr >> 8);
		result_buf[1] = (u8) (result_addr);
		ret = gtp_i2c_read(client, result_buf, data_len + 2);
		if (ret < 0)
		{
			SET_INFO_LINE_ERR("read result data failed!");
		}

		GTP_DEBUG("Result Buffer: ");
		GTP_DEBUG_ARRAY(result_buf+2, data_len);

		short_node.master_is_driver = 0;
		short_node.master = result_buf[2];

		// Rx - Rx
		for (j = 0; j < MAX_SENSOR_NUM; ++j)
		{
			if ((j == i) || ( (j < i) && (j & 0x01) == 0))
			{
				continue;
			}
			short_code = (result_buf[2+3+j*2] << 8) + result_buf[2+3+j*2+1];

			if (short_code > gt900_short_threshold)
			{
				short_node.slave_is_driver = 0;
				short_node.slave = j | GT9_SEN_HEAD;
				short_node.self_data = self_data[MAX_DRIVER_NUM + j];
				short_node.short_code = short_code;

				ret = gtp_short_resist_check(&short_node);
				if (ret == SUCCESS)
				{
					if (node_idx < GT9_INFO_NODE_MAX)
					{
						short_sum[node_idx++] = short_node;
					}
				}
			}
		}

		result_addr += data_len;
	}

	if (node_idx == 0)
	{
		ret = SUCCESS;
	}
	else
	{
		for (i = 0, j = 0; i < node_idx; ++i)
		{
			if ((short_sum[i].master_is_driver))
			{
				if (short_sum[i].master > (26 | GT9_DRV_HEAD))
				{
					short_sum[i].master--;
				}
				master = gt9_get_short_tp_chnl(short_sum[i].master-GT9_DRV_HEAD, 1);

			}
			else
			{
				master = gt9_get_short_tp_chnl(short_sum[i].master, 0);
			}

			if ((short_sum[i].slave_is_driver))
			{
				if (short_sum[i].slave > (26 | GT9_DRV_HEAD))
				{
					short_sum[i].slave--;
				}
				slave = gt9_get_short_tp_chnl(short_sum[i].slave-GT9_DRV_HEAD, 1);

			}
			else
			{
				slave = gt9_get_short_tp_chnl(short_sum[i].slave, 0);
			}
			GTP_DEBUG("Orignal Shorted Channels: %s%d, %s%d",
			          (short_sum[i].master_is_driver) ? "Drv" : "Sen", master,
			          (short_sum[i].slave_is_driver) ? "Drv" : "Sen", slave);

			if (master == 255 && slave == 255)
			{
				GTP_DEBUG("unbonded channel (%d, %d) shorted!", short_sum[i].master, short_sum[i].slave);
				continue;
			}
			else
			{
				short_sum[j].slave = slave;
				short_sum[j].master = master;
				short_sum[j].slave_is_driver = short_sum[i].slave_is_driver;
				short_sum[j].master_is_driver = short_sum[i].master_is_driver;
				short_sum[j].impedance = short_sum[i].impedance;
				short_sum[j].self_data = short_sum[i].self_data;
				short_sum[j].short_code = short_sum[i].short_code;
				++j;
			}
		}
		node_idx = j;
		if (node_idx == 0)
		{
			ret = SUCCESS;
		}
		else
		{
			for (i = 0; i < node_idx; ++i)
			{
				SET_INFO_LINE_INFO("  %s%02d & %s%02d Shorted! (R = %dKOhm)",
				                   (short_sum[i].master_is_driver) ? "Drv" : "Sen", short_sum[i].master,
				                   (short_sum[i].slave_is_driver) ? "Drv" : "Sen", short_sum[i].slave,
				                   short_sum[i].impedance);
			}
			ret = FAIL;
		}
	}
	kfree(self_data);
	kfree(short_sum);
	kfree(result_buf);
	return ret;
}

s32 gt9_test_gnd_vdd_short(struct i2c_client *client)
{

	u8 *data;
	s32 ret = 0;
	s32 i = 0;
	u16 len = (MAX_DRIVER_NUM + MAX_SENSOR_NUM) * 2;
	u16 short_code = 0;
	s32 r = -1;
	u32 short_res = 0;
	u16 amplifier = 1000;

	data = (u8 *)kmalloc(sizeof(u8) * (len + 2), GFP_KERNEL);
	if (NULL == data)
	{
		SET_INFO_LINE_ERR("failed to allocate memory for gnd vdd test data buffer");
		return FAIL;
	}

	data[0] = 0xA5;
	data[1] = 0x31;
	gtp_i2c_read(client, data, 2 + len);

	GTP_DEBUG_ARRAY(data+2, len);
	ret = SUCCESS;
	for (i = 0; i < len; i += 2)
	{
		short_code = (data[2+i] << 8) + (data[2 + i + 1]);
		if (short_code == 0)
		{
			continue;
		}
		if ((short_code & 0x8000) == 0)        // short with GND
		{
#ifdef GTP_SHORT_GND
			r = 5266285 * 10 / (short_code & (~0x8000)) - 40 * amplifier;
#endif
		}
		else    // short with VDD
		{
			//r = ( 1/(((float)(short_code&(~0x8000)))/0.9*0.7/1024/(sys.avdd-0.9)/40) ) -40;
#ifdef GTP_VDD
			r = 40*9*1024*(100*GTP_VDD - 900)/((short_code&(~0x8000))*7) - 40*1000;
			GTP_DEBUG("vdd short_code: %d", short_code & (~0x8000));
#endif
		}
		GTP_DEBUG("resistor: %d, short_code: %d", r, short_code);

		short_res = (r >= 0) ? r : 0xFFFF;
		if (short_res == 0xFFFF)
		{
		}
		else
		{
			if (short_res < (gt900_gnd_resistor_threshold * amplifier))
			{
				if (i < MAX_DRIVER_NUM * 2)       // driver
				{
					SET_INFO_LINE_INFO("  Drv%02d & GND/VDD Shorted! (R = %dKOhm)", ChannelPackage_TX[i/2], short_res/amplifier);
				}
				else
				{
					SET_INFO_LINE_INFO("  Sen%02d & GND/VDD Shorted! (R = %dKOhm)", (i/2) - MAX_DRIVER_NUM, short_res/amplifier);
				}
				ret = FAIL;
			}
		}
	}
	return ret;
}


/*
 * leave short test
 */
void gt9xx_leave_short_test(struct i2c_client *client)
{
	// boot from rom and download code from flash to ram
	gtp_write_register(client, _rRW_MISCTL__BOOT_CTL_, 0x99);
	gtp_write_register(client, _rRW_MISCTL__BOOTCTL_B0_, 0x08);

	gtp_reset_guitar(client, 20);
	msleep(100);

	gtp_send_cfg(client);
	msleep(300);
	SET_INFO_LINE_INFO("");
	SET_INFO_LINE_INFO("---gtp short test end---");

	return;
}


/*
 * Function:
 *		gt9 series ic short test function
 * Input:
 * 		I2c_client, i2c device
 * Return:
 * 		SUCCESS: test succeed, FAIL: test failed
 */
s32 gt9xx_short_test(struct i2c_client * client)
{
	s32 ret = 0;
	s32 ret2 = 0;
	u8 i = 0;
	u8 opr_buf[60] = {0};
	u8 retry = 0;
	u8 drv_sen_chksum = 0;
	struct goodix_ts_data *ts;

	ts = i2c_get_clientdata(i2c_connect_client);
	//gtp_irq_disable(ts);
	disable_irq(ts->client->irq);
#if GTP_ESD_PROTECT
	ts->gtp_is_suspend = 1;     // suspend esd
#endif
	// step 1: reset guitar, delay 1ms,  hang up ss51 and dsp
	SET_INFO_LINE_INFO("---gtp short test---");
	SET_INFO_LINE_INFO("Step 1: reset guitar, hang up ss51 dsp");

	gt9xx_short_parse_cfg();

	// RST output low last at least 2ms
	GTP_GPIO_OUTPUT(ts->pdata->reset_gpio, 0);
	msleep(2);

	// select I2C slave addr,INT:0--0xBA;1--0x28.
	GTP_GPIO_OUTPUT(ts->pdata->irq_gpio, (client->addr == 0x14));
	msleep(2);

	// RST output high reset guitar
	GTP_GPIO_OUTPUT(ts->pdata->reset_gpio, 1);

	while(retry++ < 200)
	{
		// Hold ss51 & dsp
		ret = gtp_write_register(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
		if(ret <= 0)
		{
			GTP_DEBUG("Hold ss51 & dsp I2C error,retry:%d", retry);
			gtp_reset_guitar(client, 10);
			continue;
		}

		// Confirm hold
		ret = gtp_read_register(client, _rRW_MISCTL__SWRST_B0_, opr_buf);
		if(ret <= 0)
		{
			GTP_DEBUG("Hold ss51 & dsp I2C error,retry:%d", retry);
			gtp_reset_guitar(client, 10);
			continue;
		}
		if(0x0C == opr_buf[GTP_ADDR_LENGTH])
		{
			GTP_DEBUG("Hold ss51 & dsp confirm SUCCESS");
			break;
		}
		GTP_DEBUG("Hold ss51 & dsp confirm 0x4180 failed,value:%d", opr_buf[GTP_ADDR_LENGTH]);
	}
	if(retry >= 200)
	{
		GTP_ERROR("Enter update Hold ss51 failed.");
		return FAIL;
	}
	// DSP_CK and DSP_ALU_CK PowerOn
	gtp_write_register(client, 0x4010, 0x00);
	SET_INFO_LINE_INFO("Enter short test mode SUCCESS.");

	// step2: burn dsp_short code
	SET_INFO_LINE_INFO("Step 2: burn dsp_short code");
	gtp_write_register(client, _bRW_MISCTL__TMR0_EN, 0x00); // clear watchdog
	gtp_write_register(client, _bRW_MISCTL__CACHE_EN, 0x00); // clear cache
	gtp_write_register(client, _rRW_MISCTL__BOOTCTL_B0_, 0x02); // boot from sram
	gtp_write_register(client, _bWO_MISCTL__CPU_SWRST_PULSE, 0x01); // reset software
	gtp_write_register(client, _bRW_MISCTL__SRAM_BANK, 0x00); // select bank 0
	gtp_write_register(client, _bRW_MISCTL__MEM_CD_EN, 0x01); // allow AHB bus accessing code sram

	// ---: burn dsp_short code
	retry=0;
	while(retry < 3)
	{
		SET_INFO_LINE_INFO("		retry time: %d", retry);
		ret = gtp_burn_dsp_short(client);
		if ((ret == FAIL)&&(retry==2))
		{
			SET_INFO_LINE_ERR("Step 2: burn dsp_short failed!");
			goto short_test_exit;

		}
		else if(ret==SUCCESS)
		{
			SET_INFO_LINE_INFO("Step 2: burn dsp_short success!");
			break;
		}
		SET_INFO_LINE_ERR("burn dsp_short failed!try again!");
		retry++;
	}
	/*
	ret = gtp_burn_dsp_short(client);
	if (ret == FAIL)
	{
		SET_INFO_LINE_ERR("step2: burn dsp_short failed!");
		goto short_test_exit;
	}
	*/
	// step3: run dsp_short, read results
	SET_INFO_LINE_INFO("Step 3: run dsp_short code, confirm it's runnin'");
	gtp_write_register(client, _rRW_MISCTL__SHORT_BOOT_FLAG, 0x00);	// clear dsp_short running flag
	gtp_write_register(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x03);//set scramble

	ret = gt9xx_set_ic_msg(client, _bWO_MISCTL__CPU_SWRST_PULSE, 0x01);           //20121114
	gtp_write_register(client, _rRW_MISCTL__SWRST_B0_, 0x08);	// release dsp

	msleep(80);
	// confirm dsp is running
	i = 0;
	while (1)
	{
		opr_buf[2] = 0x00;
		gtp_read_register(client, _rRW_MISCTL__SHORT_BOOT_FLAG, opr_buf);
		if (opr_buf[2] == 0xAA)
		{
			break;
		}
		++i;
		if (i >= 8)
		{
			SET_INFO_LINE_ERR("Step 3: dsp is not running!");
			goto short_test_exit;
		}
		msleep(10);
	}
	// step4: host configure ic, get test result
	SET_INFO_LINE_INFO("Step 4: host config ic, get test result");
	// Short Threshold
	GTP_DEBUG(" Short Threshold: %d", gt900_short_threshold);
	opr_buf[0] = (u8) (GTP_REG_SHORT_TH >> 8);
	opr_buf[1] = (u8) GTP_REG_SHORT_TH;
	opr_buf[2] = (u8)(gt900_short_threshold >> 8);
	opr_buf[3] = (u8)(gt900_short_threshold & 0xFF);
	gtp_i2c_write(client, opr_buf, 4);

	// ADC Read Delay
	GTP_DEBUG(" ADC Read Delay: %d", gt900_adc_read_delay);
	opr_buf[1] += 2;
	opr_buf[2] = (u8)(gt900_adc_read_delay >> 8);
	opr_buf[3] = (u8)(gt900_adc_read_delay & 0xFF);
	gtp_i2c_write(client, opr_buf, 4);

	// DiffCode Short Threshold
	GTP_DEBUG(" DiffCode Short Threshold: %d", gt900_diffcode_short_threshold);
	opr_buf[0] = 0x88;
	opr_buf[1] = 0x51;
	opr_buf[2] = (u8)(gt900_diffcode_short_threshold >> 8);
	opr_buf[3] = (u8)(gt900_diffcode_short_threshold & 0xFF);
	gtp_i2c_write(client, opr_buf, 4);

	// Config Driver & Sensor Order
#if GTP_DEBUG_ON
	printk("<<-GTP-DEBUG->>: Driver Map:\n");
	printk("IC Driver:");
	for (i = 0; i < MAX_DRIVER_NUM; ++i)
	{
		printk(" %d", cfg_drv_order[i]);
	}
	printk("\n");
	printk("TP Driver:");
	for (i = 0; i < MAX_DRIVER_NUM; ++i)
	{
		printk(" %d", i);
	}
	printk("\n");

	printk("<<-GTP-DEBUG->>: Sensor Map:\n");
	printk("IC Sensor:");
	for (i = 0; i < MAX_SENSOR_NUM; ++i)
	{
		printk(" %d", cfg_sen_order[i]);
	}
	printk("\n");
	printk("TP Sensor:");
	for (i = 0; i < MAX_SENSOR_NUM; ++i)
	{
		printk(" %d", i);
	}
	printk("\n");
#endif

	opr_buf[0] = 0x88;
	opr_buf[1] = 0x08;
	for (i = 0; i < MAX_DRIVER_NUM; ++i)
	{
		opr_buf[2 + i] = cfg_drv_order[i];
		drv_sen_chksum += cfg_drv_order[i];
	}
	gtp_i2c_write(client, opr_buf, MAX_DRIVER_NUM + 2);

	opr_buf[0] = 0x88;
	opr_buf[1] = 0x32;
	for (i = 0; i < MAX_SENSOR_NUM; ++i)
	{
		opr_buf[2+i] = cfg_sen_order[i];
		drv_sen_chksum += cfg_sen_order[i];
	}
	gtp_i2c_write(client, opr_buf, MAX_SENSOR_NUM + 2);

	opr_buf[0] = 0x88;
	opr_buf[1] = 0x50;
	opr_buf[2] = drv_sen_chksum;
	gtp_i2c_write(client, opr_buf, 2 + 1);

	// clear waiting flag, run dsp
	gtp_write_register(client, _rRW_MISCTL__SHORT_BOOT_FLAG, 0x04);

	// inquirying test status until it's okay
	for (i = 0;; ++i)
	{
		gtp_read_register(client, 0x8800, opr_buf);
		if (opr_buf[2] == 0x88)
		{
			break;
		}
		msleep(50);
		if ( i > 100 )
		{
			SET_INFO_LINE_ERR("step 4: inquiry test status timeout!");
			goto short_test_exit;
		}
	}

	// step 5: compute the result
	/* short flag:
	      bit0: Rx & Rx
	      bit1: Tx & Tx
	      bit2: Tx & Rx
	      bit3: Tx/Rx & GND/VDD
	*/
	gtp_read_register(client, 0x8801, opr_buf);
	GTP_DEBUG("short_flag = 0x%x", opr_buf[2]);
	SET_INFO_LINE_INFO("");
	SET_INFO_LINE_INFO("Short Test Result:");
	if ((opr_buf[2] & 0x0f) == 0)
	{
		SET_INFO_LINE_INFO("PASS!");
		ret = SUCCESS;
	}
	else
	{
		if ((opr_buf[2] & 0x08) == 0x08)
		{
			ret2 = gt9_test_gnd_vdd_short(client);

		}
		ret = gtp_compute_rslt(client);
		if (ret == SUCCESS && ret2 == SUCCESS)
		{
			SET_INFO_LINE_INFO("PASS!");
		}
	}
	gt9xx_leave_short_test(client);
	//gtp_irq_enable(ts);
	enable_irq(ts->client->irq);

#if GTP_ESD_PROTECT
	ts->gtp_is_suspend = 0;     // resume esd
#endif
	test_result=ret; // add by leo for ATD
	return ret;

short_test_exit:
	gt9xx_leave_short_test(client);
	//gtp_irq_enable(ts);
	enable_irq(ts->client->irq);
#if GTP_ESD_PROTECT
	ts->gtp_is_suspend = 0;     // resume esd
#endif
	test_result=FAIL; // add by leo for ATD
	return FAIL;
}

u32 endian_mode(void)
{
	union
	{
		s32 i;
		s8 c;
	} endian;

	endian.i = 1;

	if (1 == endian.c)
	{
		return MYBIG_ENDIAN;
	}
	else
	{
		return MYLITLE_ENDIAN;
	}
}
/*
*********************************************************************************************************
* Function:
*	send read rawdata cmd
* Input:
*	i2c_client* client: i2c device
* Return:
* 	SUCCESS: send process succeed, FAIL: failed
*********************************************************************************************************
*/
s32 gt9_read_raw_cmd(struct i2c_client* client)
{
	u8 raw_cmd[3] = {(u8)(GTP_REG_READ_RAW >> 8), (u8)GTP_REG_READ_RAW, 0x01};
	s32 ret = -1;

	ret = gtp_i2c_write(client, raw_cmd, 3);
	if(ret <= 0)
	{
		SET_INFO_LINE_ERR("i2c write failed.");
		return FAIL;
	}
	msleep(10);
	return SUCCESS;
}

s32 gt9_read_coor_cmd(struct i2c_client *client)
{
	u8 raw_cmd[3] = {(u8)(GTP_REG_READ_RAW >> 8), (u8)GTP_REG_READ_RAW, 0x0};
	s32 ret = -1;

	ret = gtp_i2c_write(client, raw_cmd, 3);
	if (ret < 0)
	{
		SET_INFO_LINE_ERR("i2c write coor cmd failed!");
		return FAIL;
	}
	msleep(10);
	return SUCCESS;
}
/*
*********************************************************************************************************
* Function:
*	read rawdata from ic registers
* Input:
*	u16* data: rawdata buffer
* 	i2c_client* client: i2c device
* Return:
* 	SUCCESS: read process succeed, FAIL:  failed
*********************************************************************************************************
*/
static u16 real_raw_data[TOTAL_PIXEL_NUM]= {0};

s32 gtp_read_rawdata(struct i2c_client* client, u16* data)
{
	s32 ret = -1;
	u16 retry = 0;
	//u8  end_cmd[3] = {GTP_READ_COOR_ADDR >> 8, GTP_READ_COOR_ADDR & 0xFF, 0};
	u8 read_state[3] = {(u8)(GTP_REG_RAW_READY>>8), (u8)GTP_REG_RAW_READY, 0};
	u16 i = 0, j = 0, k = 0;
	u8 *read_rawbuf;
	u8 tail, head;
	//u16 real_raw_data[TOTAL_PIXEL_NUM]= {0}; // add by leo

	read_rawbuf = (u8*)kmalloc(sizeof(u8) * (gt9xx_pixel_cnt * 2 + GTP_ADDR_LENGTH), GFP_KERNEL);

	if (NULL == read_rawbuf)
	{
		SET_INFO_LINE_ERR("failed to allocate for read_rawbuf");
		return FAIL;
	}
	read_rawbuf[0] = (u8)( GTP_REG_RAW_DATA >> 8);
	read_rawbuf[1] = (u8)( GTP_REG_RAW_DATA );

	if(data == NULL)
	{
		SET_INFO_LINE_ERR("Invalid raw buffer.");
		goto have_error;
	}

	msleep(10);
	while (retry++ < GTP_WAIT_RAW_MAX_TIMES)
	{
		ret = gtp_i2c_read(client, read_state, 3);
		if(ret <= 0)
		{
			SET_INFO_LINE_ERR("i2c read failed.return: %d", ret);
			continue;
		}
		if(read_state[GTP_ADDR_LENGTH] == 0x80)
		{
			GTP_DEBUG("Raw data is ready.");
			break;
		}
		if ((retry/10) == 0)
		{
			GTP_DEBUG("read_state[2] = 0x%x", read_state[GTP_ADDR_LENGTH]);
		}
		msleep(5);
	}
	if (retry >= GTP_WAIT_RAW_MAX_TIMES)
	{
#if 0
		SET_INFO_LINE_ERR("Wait raw data ready timeout.");
		goto have_error;

#else
		gtp_reset_guitar(client, 20);  //reset touch IC
		msleep(300);
		SET_INFO_LINE_ERR("Reset touch IC and into raw mode.");

		ret = gt9_read_raw_cmd(client); // change to raw data mode again
		if (ret == FAIL)
		{
			SET_INFO_LINE_ERR("Send Read Rawdata Cmd failed!");
		}

		retry = 0;
		while (retry++ < GTP_WAIT_RAW_MAX_TIMES) // try to read raw data again
		{
			ret = gtp_i2c_read(client, read_state, 3);
			if(ret <= 0)
			{
				SET_INFO_LINE_ERR("i2c read failed.return: %d", ret);
				continue;
			}
			if(read_state[GTP_ADDR_LENGTH] == 0x80)
			{
				GTP_DEBUG("Raw data is ready.");
				break;
			}
			if ((retry/10) == 0)
				GTP_DEBUG("read_state[2] = 0x%x", read_state[GTP_ADDR_LENGTH]);
			msleep(5);
		}
		if (retry >= GTP_WAIT_RAW_MAX_TIMES)
		{
			SET_INFO_LINE_ERR("Wait raw data ready timeout.");
			goto have_error;
		}
#endif
	}

	ret = gtp_i2c_read(client, read_rawbuf, GTP_ADDR_LENGTH + ((gt9xx_drv_num*gt9xx_sen_num)*2));
	if(ret <= 0)
	{
		SET_INFO_LINE_ERR("i2c read rawdata failed.");
		goto have_error;
	}
	gtp_i2c_end_cmd(client);	// clear buffer state

	if (endian_mode() == MYBIG_ENDIAN)
	{
		head = 0;
		tail =1;
		GTP_DEBUG("Big Endian.");
	}
	else
	{
		head = 1;
		tail = 0;
		GTP_DEBUG("Little Endian.");
	}

	for(i=0,j = 0; i < ((gt9xx_drv_num*gt9xx_sen_num)*2); i+=2)
	{
		real_raw_data[i/2] = (u16)(read_rawbuf[i+head+GTP_ADDR_LENGTH]<<8) + (u16)read_rawbuf[GTP_ADDR_LENGTH+i+tail];
#if GTP_DEBUG_ARRAY_ON
		GTP_DEBUG("%d ", data[i/2]);
		++j;
		if((j%gt9xx_drv_num) == 0)
			GTP_DEBUG("\n");
#endif
	}

	// Transfor raw data from 32x24 to 24x32
	for(i=0; i < gt9xx_drv_num ; i++)
	{
		for(j=0; j < gt9xx_drv_num*gt9xx_sen_num ; j+=gt9xx_sen_num,k++)
		{
			data[k]= real_raw_data[i+j];
			//printk("////////////////////		real_raw_data[%d]=%d\n",i,data[i+j]);
		}
		if(k==TOTAL_PIXEL_NUM)break;
	}

	kfree(read_rawbuf);
	return SUCCESS;
have_error:
	kfree(read_rawbuf);
	return FAIL;
}
/*
*********************************************************************************************************
* Function:
*	rawdata test initilization function
* Input:
*	u32 check_types: test items
*********************************************************************************************************
*/
static void gtp_raw_test_init(u32 check_types)
{
	u16 i = 0;

	test_rslt_buf = (s32*) kmalloc(sizeof(s32)*sample_set_num, GFP_ATOMIC);
	touchpad_sum = (struct gt9xx_open_info*) kmalloc(sizeof(struct gt9xx_open_info) * 4 * _BEYOND_REC_MAX, GFP_ATOMIC);
	if (NULL == test_rslt_buf || touchpad_sum == NULL)
	{
		SET_INFO_LINE_ERR("Test result buffer allocate failed!");
	}
	memset(touchpad_sum, 0, sizeof(struct gt9xx_open_info) * 4 * _BEYOND_REC_MAX);
	for (i = 0; i < gt9xx_drv_num*gt9xx_sen_num; i++)
	{
		if (i < sample_set_num)
		{
			test_rslt_buf[i] = _CHANNEL_PASS;
		}
	}

	return;
}

/*
*********************************************************************************************************
* Function:
*	touchscreen rawdata min limit test
* Input:
*	u16* raw_buf: rawdata buffer
*********************************************************************************************************
*/
static void gtp_raw_min_test(u16 *raw_buf)
{
	u16 i=0, j=0, min_limit=0;
	u8 driver, sensor;
	u8 sum_base = 1 * _BEYOND_REC_MAX;
	u8 new_flag = 0;

	for (i = 0; i < gt9xx_sc_pxl_cnt; i++)
	{
		if(AbsoluteTotalCheck)
			min_limit=min_limit_value;
		else
			min_limit=gt928_raw_acc_spec[i].min_rawdata;

		//if (raw_buf[i] < min_limit_value)
		//if (raw_buf[i] < gt928_raw_acc_spec[i].min_rawdata)
		if (raw_buf[i] < min_limit)
		{
			test_rslt_buf[rslt_buf_idx] |= _BEYOND_MIN_LIMIT;
			driver = (i/gt9xx_sen_num) + 1;
			sensor = (i%gt9xx_sen_num) + 1;
			new_flag = 0;
			for (j = sum_base; j < (sum_base+_BEYOND_REC_MAX); ++j)
			{
				if (touchpad_sum[j].driver == 0)
				{
					new_flag = 1;
					break;
				}
				if ((driver == touchpad_sum[j].driver) && (sensor == touchpad_sum[j].sensor))
				{
					touchpad_sum[j].times++;
					new_flag = 0;
					break;
				}
			}
			if (new_flag)	// new one
			{
				touchpad_sum[j].driver = driver;
				touchpad_sum[j].sensor = sensor;
				touchpad_sum[j].beyond_type |= _BEYOND_MIN_LIMIT;
				touchpad_sum[j].raw_val = raw_buf[i];
				touchpad_sum[j].times = 1;
			}
			else
			{
				continue;
			}
			//GTP_DEBUG("[%d, %d]rawdata: %d, raw min limit: %d", driver, sensor, raw_buf[i], min_limit_value);
			//GTP_DEBUG("[%d, %d]rawdata: %d, raw min limit: %d", driver, sensor, raw_buf[i], gt928_raw_acc_spec[i].min_rawdata);
			SET_INFO_LINE_INFO("[%s][%d, %d] rawdata: %d < raw min limit: %d", __FUNCTION__, driver, sensor, raw_buf[i], min_limit);
		}
	}
	return;
}

/*
*********************************************************************************************************
* Function:
*	touchscreen rawdata max limit test
* Input:
*	u16* raw_buf: rawdata buffer
*********************************************************************************************************
*/
static void gtp_raw_max_test(u16 *raw_buf)
{
	u16 i =0, j=0, max_limit=0;
	u8 driver, sensor;
	u8 sum_base = 0 * _BEYOND_REC_MAX;
	u8 new_flag = 0;

	printk("////////////////////		gtp_raw_max_test\n");

	for (i = 0; i < gt9xx_sc_pxl_cnt; i++)
	{
		if(AbsoluteTotalCheck)
			max_limit=max_limit_value;
		else
			max_limit=gt928_raw_acc_spec[i].max_rawdata;

		//printk("raw_buf[%d] =%d , max_rawdata[%d] = %d\n",i,raw_buf[i],i,gt928_raw_acc_spec[i].max_rawdata);
		//printk("max_limit = %d\n",max_limit);

		gt928_raw_data[i]=raw_buf[i];

		//if (raw_buf[i] > max_limit_value)
		//if (raw_buf[i] > gt928_raw_acc_spec[i].max_rawdata)
		if (raw_buf[i] > max_limit)
		{
			test_rslt_buf[rslt_buf_idx] |= _BEYOND_MAX_LIMIT;
			driver = (i/gt9xx_drv_num) + 1;
			sensor = (i%gt9xx_drv_num) + 1;
			new_flag = 0;
			for (j = sum_base; j < (sum_base+_BEYOND_REC_MAX); ++j)
			{
				if (touchpad_sum[j].driver == 0)
				{
					new_flag = 1;
					break;
				}
				if ((driver == touchpad_sum[j].driver) && (sensor == touchpad_sum[j].sensor))
				{
					touchpad_sum[j].times++;
					new_flag = 0;
					break;
				}
			}
			if (new_flag)	// new one
			{
				touchpad_sum[j].driver = driver;
				touchpad_sum[j].sensor = sensor;
				touchpad_sum[j].beyond_type |= _BEYOND_MAX_LIMIT;
				touchpad_sum[j].raw_val = raw_buf[i];
				touchpad_sum[j].times = 1;
			}
			else
			{
				continue;
			}

			//GTP_DEBUG("[%d, %d]rawdata: %d, raw max limit: %d", driver, sensor, raw_buf[i], max_limit_value);
			//GTP_DEBUG("[%d, %d]rawdata: %d, raw max limit: %d", driver, sensor, raw_buf[i], gt928_raw_acc_spec[i].max_rawdata);
			SET_INFO_LINE_INFO("[%s][%d, %d] rawdata: %d > raw max limit: %d", __FUNCTION__, driver, sensor, raw_buf[i], max_limit);
		}
	}
	return;
}

#if GTP_HAVE_TOUCH_KEY
/*
*********************************************************************************************************
* Function:
*	key rawdata max limit test
* Input:
*	u16* raw_buf: rawdata buffer
*********************************************************************************************************
*/
static void gtp_key_max_test(u16 *raw_buf)
{
	u16 i = 0, j = 1, k = 0;
	u8 key_cnt = key_iso_pos[0];
	u8 driver, sensor;
	u8 sum_base = 2 * _BEYOND_REC_MAX;
	u8 new_flag = 0;

	driver = gt9xx_drv_num;
	for (i = gt9xx_sc_pxl_cnt; i < gt9xx_pixel_cnt; ++i)
	{
		sensor = (i%gt9xx_sen_num) + 1;
		if (key_is_isolated)
		{
			if ((key_iso_pos[j] != sensor) || (key_cnt == 0))
			{
				continue;
			}
			else	// only test key pixel rawdata
			{
				--key_cnt;
				++j;
			}
		}
		if (raw_buf[i] > max_limit_key)
		{
			test_rslt_buf[rslt_buf_idx] |= _BEYOND_KEY_MAX_LMT;
			new_flag = 0;
			for (k = sum_base; k < (sum_base+_BEYOND_REC_MAX); ++k)
			{
				if (touchpad_sum[k].driver == 0)
				{
					new_flag = 1;
					break;
				}
				if (touchpad_sum[k].sensor == sensor)
				{
					touchpad_sum[k].times++;
					new_flag = 0;
					break;
				}
			}
			if (new_flag)	// new one
			{
				touchpad_sum[k].driver = driver;
				touchpad_sum[k].sensor = sensor;
				touchpad_sum[k].beyond_type |= _BEYOND_KEY_MAX_LMT;
				touchpad_sum[k].raw_val = raw_buf[i];
				touchpad_sum[k].times = 1;
				if (key_is_isolated)
				{
					touchpad_sum[k].key = j-1;
				}
			}
			else
			{
				continue;
			}
			SET_INFO_LINE_INFO("[%s][%d, %d] key rawdata: %d, key max limit: %d", __FUNCTION__, driver,sensor, raw_buf[i], max_limit_key);
		}
	}
	return;
}
/*
*********************************************************************************************************
* Function:
*	key rawdata min limit test
* Input:
*	u16* raw_buf: rawdata buffer
*********************************************************************************************************
*/
static void gtp_key_min_test(u16 *raw_buf)
{
	u16 i = 0, j = 1, k = 0;
	u8 key_cnt = key_iso_pos[0];
	u8 driver, sensor;
	u8 sum_base = 3 * _BEYOND_REC_MAX;
	u8 new_flag = 0;

	driver = gt9xx_drv_num;
	for (i = gt9xx_sc_pxl_cnt; i < gt9xx_pixel_cnt; ++i)
	{
		sensor = (i%gt9xx_sen_num) + 1;
		if (key_is_isolated)
		{
			if ((key_iso_pos[j] != sensor) || (key_cnt == 0))
			{
				continue;
			}
			else	// only test key pixel rawdata
			{
				--key_cnt;
				++j;
			}
		}

		if (raw_buf[i] < min_limit_key)
		{
			test_rslt_buf[rslt_buf_idx] |= _BEYOND_KEY_MIN_LMT;
			new_flag = 0;
			for (k = sum_base; k < (sum_base + _BEYOND_REC_MAX); ++k)
			{
				if (touchpad_sum[k].driver == 0)
				{
					new_flag = 1;
					break;
				}
				if (sensor == touchpad_sum[k].sensor)
				{
					touchpad_sum[k].times++;
					break;
				}
			}
			if (new_flag)	// new one
			{
				touchpad_sum[k].driver = driver;
				touchpad_sum[k].sensor = sensor;
				touchpad_sum[k].beyond_type |= _BEYOND_KEY_MIN_LMT;
				touchpad_sum[k].raw_val = raw_buf[i];
				touchpad_sum[k].times = 1;
				if (key_is_isolated)
				{
					touchpad_sum[k].key = j-1;
				}
			}
			else
			{
				continue;
			}
			SET_INFO_LINE_INFO("[%s][%d, %d] key rawdata: %d, key min limit: %d", __FUNCTION__, driver, sensor, raw_buf[i], min_limit_key);
		}
	}
	return;
}
#endif

// add by leo for area accord check ++
/*
*********************************************************************************************************
* Function:
*	key rawdata area accord limit test
* Input:
*	u16* raw_buf: rawdata buffer
*********************************************************************************************************
*/
static void gtp_raw_acc_test(u16 *raw_buf)
{
	u16 i=0, j=0;
	u16 four_data[4]= {0}, acc_ans=0;
	u32 max_acc_data=0, min_acc_data=0;
	u8 driver=0, sensor=0;
	u8 sum_base = 3 * _BEYOND_REC_MAX;
	u8 new_flag = 0;

	//printk("////////////////////		gtp_raw_acc_test\n");

	for (i = 0; i < gt9xx_sc_pxl_cnt; i++)
	{
		//get up/down/left/right data
		(i < gt9xx_drv_num) ? (four_data[0] = raw_buf[i]) : (four_data[0] = raw_buf[i - gt9xx_drv_num]);        //get  up
		(i >= (gt9xx_sc_pxl_cnt - gt9xx_drv_num)) ? (four_data[1] = raw_buf[i]) : (four_data[1] = raw_buf[i + gt9xx_drv_num]); //get down
		(((i + 1) % gt9xx_drv_num) == 0) ? (four_data[2] = raw_buf[i]) : (four_data[2] = raw_buf[i + 1]); //right
		((i % gt9xx_drv_num) == 0) ?  (four_data[3] = raw_buf[i]) : (four_data[3] = raw_buf[i - 1]);                       //left

		//find max, min
		(four_data[0] > four_data[1]) ? (max_acc_data = four_data[0], min_acc_data = four_data[1]) : (max_acc_data = four_data[1], min_acc_data = four_data[0]);
		(max_acc_data < four_data[2]) ? (max_acc_data = four_data[2]) : 0;
		(max_acc_data < four_data[3]) ? (max_acc_data = four_data[3]) : 0;
		(min_acc_data > four_data[2]) ? (min_acc_data = four_data[2]) : 0;
		(min_acc_data > four_data[3]) ? (min_acc_data = four_data[3]) : 0;

		//cal max, min
		max_acc_data = (raw_buf[i] > max_acc_data) ? (raw_buf[i] - max_acc_data): (max_acc_data - raw_buf[i]);
		max_acc_data = (max_acc_data * 1000)/raw_buf[i];

		min_acc_data = (raw_buf[i] > min_acc_data) ? (raw_buf[i] - min_acc_data): (min_acc_data - raw_buf[i]);
		min_acc_data = (min_acc_data * 1000)/raw_buf[i];

		//sel real max
		acc_ans = (max_acc_data > min_acc_data) ? max_acc_data: min_acc_data;

		gt928_acc_data[i]=acc_ans;

		//compare
		if (gt928_acc_data[i] > gt928_raw_acc_spec[i].acc_data)
		{
			test_rslt_buf[rslt_buf_idx] |= _BEYOND_MAX_LIMIT;
			driver = (i/gt9xx_sen_num) + 1;
			sensor = (i%gt9xx_sen_num) + 1;
			new_flag = 0;
			for (j = sum_base; j < (sum_base+_BEYOND_REC_MAX); ++j)
			{
				if (touchpad_sum[j].driver == 0)
				{
					new_flag = 1;
					break;
				}
				if ((driver == touchpad_sum[j].driver) && (sensor == touchpad_sum[j].sensor))
				{
					touchpad_sum[j].times++;
					new_flag = 0;
					break;
				}
			}
			if (new_flag)	// new one
			{
				touchpad_sum[j].driver = driver;
				touchpad_sum[j].sensor = sensor;
				touchpad_sum[j].beyond_type |= _BEYOND_MAX_LIMIT;
				touchpad_sum[j].raw_val = raw_buf[i];
				touchpad_sum[j].times = 1;
			}
			else
			{
				continue;
			}
			SET_INFO_LINE_INFO("[%s][%d, %d] gt928_acc_data[%d]: %d > gt928_raw_acc_spec[%d].acc_data: %d", __FUNCTION__, driver, sensor, i, gt928_acc_data[i], i, gt928_raw_acc_spec[i].acc_data);
		}
	}
	return;
}
// add by leo for area accord check --

/*
*********************************************************************************************************
* Function:
*   gtp_raw_print
* Input:
*   u16* raw_buf: rawdata buffer
*********************************************************************************************************
*/
static void gtp_raw_print(u16 *raw_buf)
{
	u16 i = 0;
	u16 min_val = 0, max_val = 0;
	u32 avg_val = 0;

	SET_INFO_LINE_INFO("Total node number: %d", gt9xx_sc_pxl_cnt);

	//print raw data
	min_val = raw_buf[0];
	max_val = raw_buf[0];

	for (i = 0; i < gt9xx_sc_pxl_cnt; i++)
	{
		if(i%gt9xx_drv_num ==0)
		{
			if((i!=0)&&gt928_debug)printk("\n");
			if(gt928_debug)printk("S %2d: ", i/gt9xx_drv_num);
		}

		(raw_buf[i] > max_val) ? (max_val = raw_buf[i]): 0; //get max raw data
		(raw_buf[i] < min_val) ? (min_val = raw_buf[i]): 0; //get min raw data
		avg_val += raw_buf[i];

		gt928_raw_data[i]=raw_buf[i];
		if(gt928_debug)printk("%d ", raw_buf[i]);
	}
	if(gt928_debug)printk("\n");

	//SET_INFO_LINE_INFO("Test Limit Rawdata Man:%d, Min:%d", test_parameter[gtp_test_sensor_id].max_limit_value, test_parameter[gtp_test_sensor_id].min_limit_value);
	SET_INFO_LINE_INFO("Last Frame Rawdata Max:%d, Min:%d, Avg:%d", max_val, min_val, (avg_val / gt9xx_sc_pxl_cnt));

	return;
}

/*
*********************************************************************************************************
* Function:
*	analyse rawdata retrived from ic registers
* Input:
*	u16 *raw_buf, buffer for rawdata,
*   u32 check_types, test items
* Return:
*	SUCCESS: test process succeed, FAIL: failed
*********************************************************************************************************
*/
static u32 gtp_raw_test(u16 *raw_buf, u32 check_types)
{
	if (raw_buf == NULL)
	{
		GTP_DEBUG("Invalid raw buffer pointer!");
		return FAIL;
	}
	if (0 == check_types)
	{
		check_types = default_test_types;
#if GTP_HAVE_TOUCH_KEY
		check_types |= _KEY_MAX_TEST | _KEY_MIN_TEST;
#endif
	}

	if(AreaAccordCheck) // add by leo for area accord check ++
	{
		if(check_types & _MAX_TEST)
		{
			gtp_raw_acc_test(raw_buf);
		}
	}
	else
	{
		if (check_types & _MAX_TEST)
		{
			gtp_raw_max_test(raw_buf);		// ?\C6\C1\D7\EE\B4\F3?\B2\E2\CA\D4
		}
		if (check_types & _MIN_TEST)
		{
			gtp_raw_min_test(raw_buf);		// ?\C6\C1\D7\EE?\B2\E2\CA\D4
		}

#if GTP_HAVE_TOUCH_KEY
		if (check_types & _KEY_MAX_TEST)
		{
			gtp_key_max_test(raw_buf);
		}
		if (check_types & _KEY_MIN_TEST)
		{
			gtp_key_min_test(raw_buf);
		}
#endif
	}




	return SUCCESS;
}

/*
====================================================================================================
* Function:
* 	output the test result
* Return:
* 	return the result. if result == 0, the TP is ok, otherwise list the beyonds
====================================================================================================
*/

static s32 gtp_get_test_result(void)
{
	u16 i = 0, j = 0;
	u16 beyond_max_num = 0;			// beyond max limit test times
	u16 beyond_min_num = 0;			// beyond min limit test times
#if GTP_HAVE_TOUCH_KEY
	u16 beyond_key_max = 0;			// beyond key max limit test times
	u16 beyond_key_min = 0;			// beyond key min limit test times
#endif
	s32 result = _CHANNEL_PASS;

#if GTP_DEBUG_ON
	for (i = 0; i < 4 * _BEYOND_REC_MAX; ++i)
	{
		printk("(%2d, %2d)[%2d] ", touchpad_sum[i].driver, touchpad_sum[i].sensor, touchpad_sum[i].times);
		if (i && ((i+1) % 5 == 0))
		{
			printk("\n");
		}
	}
	printk("\n");
#endif

	for (i = 0; i < sample_set_num; ++i)
	{
		if (test_rslt_buf[i] & _BEYOND_MAX_LIMIT)
		{
			beyond_max_num++;
		}
		if (test_rslt_buf[i] & _BEYOND_MIN_LIMIT)
		{
			beyond_min_num++;
		}
#if GTP_HAVE_TOUCH_KEY
		if (test_rslt_buf[i] & _BEYOND_KEY_MAX_LMT)
		{
			beyond_key_max++;
		}
		if (test_rslt_buf[i] & _BEYOND_KEY_MIN_LMT)
		{
			beyond_key_min++;
		}
#endif
	}
	if (beyond_max_num > _MIN_ERROR_NUM)
	{
		result |= _BEYOND_MAX_LIMIT;
		j = 0;
		SET_INFO_LINE_INFO("Beyond Max Limit Points Info: ");
		for (i = 0; i < _BEYOND_REC_MAX; ++i)
		{
			if (touchpad_sum[i].driver == 0)
			{
				break;
			}
			SET_INFO_LINE_INFO("  Drv: %d, Sen: %d[Times: %d]", touchpad_sum[i].driver, touchpad_sum[i].sensor, touchpad_sum[i].times);
		}
	}
	if (beyond_min_num > _MIN_ERROR_NUM)
	{
		result |= _BEYOND_MIN_LIMIT;
		SET_INFO_LINE_INFO("Beyond Min Limit Points Info:");
		j = 0;
		for (i = _BEYOND_REC_MAX; i < (2*_BEYOND_REC_MAX); ++i)
		{
			if (touchpad_sum[i].driver == 0)
			{
				break;
			}
			SET_INFO_LINE_INFO("  Drv: %d, Sen: %d[Times: %d]", touchpad_sum[i].driver, touchpad_sum[i].sensor, touchpad_sum[i].times);
		}
	}
#if GTP_HAVE_TOUCH_KEY
	if (beyond_key_max > _MIN_ERROR_NUM)
	{
		result |= _BEYOND_KEY_MAX_LMT;
		SET_INFO_LINE_INFO("Beyond Key Max Limit Key Info:");
		for (i = 2*_BEYOND_REC_MAX; i < (3*_BEYOND_REC_MAX); ++i)
		{
			if (touchpad_sum[i].driver == 0)
			{
				break;
			}
			SET_INFO_LINE_INFO("  Drv: %d, Sen: %d[Times: %d]", touchpad_sum[i].driver, touchpad_sum[i].sensor, touchpad_sum[i].times);
		}
	}
	if (beyond_key_min > _MIN_ERROR_NUM)
	{
		result |= _BEYOND_KEY_MIN_LMT;
		SET_INFO_LINE_INFO("Beyond Key Min Limit Key Info:");
		for (i = 3*_BEYOND_REC_MAX; i < (4*_BEYOND_REC_MAX); ++i)
		{
			if (touchpad_sum[i].driver == 0)
			{
				break;
			}
			SET_INFO_LINE_INFO("  Drv: %d, Sen: %d[Times: %d]", touchpad_sum[i].driver, touchpad_sum[i].sensor, touchpad_sum[i].times);
		}
	}
#endif

	if (result == 0)
	{
		SET_INFO_LINE_INFO("[TEST SUCCEED]: The TP is ok!");
		test_result=SUCCESS; // add by leo for ATD
		return result;
	}
	SET_INFO_LINE_INFO("[TEST FAILED]:");
	test_result=FAIL; // add by leo for ATD
	if (result & _BEYOND_MAX_LIMIT)
	{
		SET_INFO_LINE_INFO("Beyond Raw Max Limit[Max Limit: %d]", max_limit_value);
	}
	if (result & _BEYOND_MIN_LIMIT)
	{
		SET_INFO_LINE_INFO("Beyond Raw Min Limit[Min Limit: %d]", min_limit_value);
	}
#if GTP_HAVE_TOUCH_KEY
	if (result & _BEYOND_KEY_MAX_LMT)
	{
		SET_INFO_LINE_INFO("Beyond KeyVal Max Limit[Key Max Limit: %d]", max_limit_key);
	}
	if (result & _BEYOND_KEY_MIN_LMT)
	{
		SET_INFO_LINE_INFO("Beyond KeyVal Min Limit[Key Min Limit: %d]", min_limit_key);
	}
#endif

	return result;
}

/*
 ===================================================
 * Function:
 * 		test gt9 series ic open test
 * Input:
 * 		client, i2c_client
 * Return:
 * 		SUCCESS: test process success, FAIL, test process failed
 *
 ===================================================
*/

s32 gt9xx_open_test(struct i2c_client * client)
{
	u16 i = 0;
	s32 ret = 0; // SUCCESS, FAIL
	struct goodix_ts_data *ts;
	u16 *raw_buf = NULL;

	ts = i2c_get_clientdata(i2c_connect_client);
	gtp_irq_disable(ts);
	SET_INFO_LINE_INFO("---gtp open test---");
	GTP_DEBUG("Parsing configuration...");
	ret = gtp_parse_config();
	if (ret == FAIL)
	{
		SET_INFO_LINE_ERR("failed to parse config...");
		goto open_test_exit;
	}

	raw_buf = (u16*)kmalloc(sizeof(u16)* gt9xx_pixel_cnt, GFP_KERNEL);
	if (NULL == raw_buf)
	{
		SET_INFO_LINE_ERR("failed to allocate mem for raw_buf!");
		goto open_test_exit;
	}

	GTP_DEBUG("Step 1: Send Rawdata Cmd");

	ts->gtp_rawdiff_mode = 1;
	gtp_raw_test_init(0);

	ret = gt9_read_raw_cmd(client);
	if (ret == FAIL)
	{
		SET_INFO_LINE_ERR("Send Read Rawdata Cmd failed!");
		goto open_test_exit;
	}

	GTP_DEBUG("Step 2: Sample Rawdata");

	// add by leo for dynamic change limit value ++
	max_limit_value = TotalMaxValue;
	min_limit_value = TotalMinValue;
	//gt928_raw_acc_spec=&GuitarTestPlatformINI;
	for(i=0;i<TOTAL_PIXEL_NUM;i=i+4)
	{
		gt928_raw_acc_spec[i].node_number = GuitarTestPlatformINI[i];
		gt928_raw_acc_spec[i+1].max_rawdata = GuitarTestPlatformINI[i+1];
		gt928_raw_acc_spec[i+2].min_rawdata = GuitarTestPlatformINI[i+2];
		gt928_raw_acc_spec[i+3].acc_data = GuitarTestPlatformINI[i+3];
	}

	if((AbsoluteTotalCheck)&&(!AreaAccordCheck))
	{
		GTP_INFO("AbsoluteTotalCheck = %s, AreaAccordCheck = %s", (AbsoluteTotalCheck)?"true":"false", (AreaAccordCheck)?"true":"false");
		GTP_INFO("Open Test");
		GTP_INFO("Max Limit Value: %d", max_limit_value);
		GTP_INFO("Min Limit Value: %d", min_limit_value);
	}
	else if((!AbsoluteTotalCheck)&&(!AreaAccordCheck))
	{
		GTP_INFO("AbsoluteTotalCheck = %s, AreaAccordCheck = %s", (AbsoluteTotalCheck)?"true":"false", (AreaAccordCheck)?"true":"false");
		GTP_INFO("Open Test - compare single point by each Max & Min\n");
	}
	else
	{
		GTP_INFO("AbsoluteTotalCheck = %s, AreaAccordCheck = %s", (AbsoluteTotalCheck)?"true":"false", (AreaAccordCheck)?"true":"false");
		GTP_INFO("Area Accord Test\n");
	}
	// add by leo for dynamic change limit value --

	for (i = 0; i < sample_set_num; ++i)
	{
		GTP_DEBUG("sample time: %d", i);

		rslt_buf_idx = i;
		ret = gtp_read_rawdata(client, raw_buf);
		if (ret == FAIL)
		{
			SET_INFO_LINE_ERR("Read Rawdata failed!");
			goto open_test_exit;
		}
		ret = gtp_raw_test(raw_buf, 0);
		if (ret == FAIL)
		{
			gtp_i2c_end_cmd(client);
			continue;
		}
	}

	// add by leo for dump raw data ++
#if 0
	for (i = 0; i < gt9xx_sc_pxl_cnt; i++)
	{
		gt928_raw_data[i]=raw_buf[i];
	}
#else
	gtp_raw_print(raw_buf); // add by leo only printf last raw data infor
#endif
	// add by leo for dump raw data --

	GTP_DEBUG("Step 3: Analyse Result");
	SET_INFO_LINE_INFO("Total %d Sample Data", sample_set_num);
	gtp_get_test_result();

	ret = SUCCESS;
open_test_exit:

	kfree(raw_buf);
	if (test_rslt_buf)
	{
		kfree(test_rslt_buf);
	}
	if (touchpad_sum)
	{
		kfree(touchpad_sum);
	}

	//add by leo for wait raw data ready timeout issue --
	//gtp_reset_guitar(client, 20);
	//msleep(100);
	gtp_send_cfg(client);
	msleep(300);
	//add by leo for wait raw data ready timeout issue --

	gtp_irq_enable(ts);
	ts->gtp_rawdiff_mode = 0;
	gt9_read_coor_cmd(client);	// back to read coordinates data
	SET_INFO_LINE_INFO("---gtp open test end---");
	gtp_i2c_write(ts->client, config, GTP_ADDR_LENGTH + GTP_CONFIG_MAX_LENGTH);
	return ret;
}

/*
 ===================================================
 * Function:
 *      test gt9 series ic disable
 * Input:
 *      client, i2c_client
 * Return:
 *      SUCCESS: test process success, FAIL, test process failed
 *
 ===================================================
*/
void gt9xx_tp_disable(struct i2c_client *client)
{
	s8 ret = -1;
	u8 i2c_control_buf[3] = {(u8)(GTP_REG_SLEEP >> 8), (u8)GTP_REG_SLEEP, 5};
	struct goodix_ts_data *ts;

	ts = i2c_get_clientdata(client);

	//gtp_irq_disable(ts);
	//disable_irq(ts->client->irq);
#if GTP_ESD_PROTECT
	ts->gtp_is_suspend = 1;     // suspend esd
#endif

	//enter sleep
	GTP_GPIO_OUTPUT(ts->pdata->irq_gpio, 0);
	msleep(5);

	ret = gtp_i2c_write(ts->client, i2c_control_buf, 3);
	if (ret > 0)
	{
		GTP_INFO("GTP enter sleep!");
	}
	else
	{
		GTP_ERROR("GTP send sleep cmd failed.");
		return;
	}
	SET_INFO_LINE_INFO("---gtp enter sleep---");

	//gtp_irq_enable(ts);
	//enable_irq(ts->client->irq);
#if GTP_ESD_PROTECT
	//ts->gtp_is_suspend = 0; 	// resume esd, due to into sleep can't response ESD ask
#endif

	return;
}

/*
 ===================================================
 * Function:
 *      test gt9 series ic enable
 * Input:
 *      client, i2c_client
 * Return:
 *      SUCCESS: test process success, FAIL, test process failed
 *
 ===================================================
*/
void gt9xx_tp_enable(struct i2c_client * client)
{
	struct goodix_ts_data *ts;

	ts = i2c_get_clientdata(client);

	//gtp_irq_disable(ts);
	//disable_irq(ts->client->irq);
#if GTP_ESD_PROTECT
	//ts->gtp_is_suspend = 1;     // suspend esd
#endif

	//wakeup or reset gtp
	//gtp_wakeup_sleep(ts);	//wakeup
	gtp_reset_guitar(ts->client, 50);	//add by one
	SET_INFO_LINE_INFO("---gtp restart---");

	//gtp_irq_enable(ts);
	//enable_irq(ts->client->irq);
#if GTP_ESD_PROTECT
	ts->gtp_is_suspend = 0; 	// resume esd
#endif

	return;
}

static ssize_t gtp_sysfs_shorttest_show(struct device *dev,struct device_attribute *attr, char *buf)
{
	u8 index;
	u32 len;
	int ret=0;
	struct goodix_ts_data *ts;

	ts = i2c_get_clientdata(i2c_connect_client);

	ret = gtp_wakeup_sleep(ts);
	gtp_irq_disable(ts);

	gt9xx_short_test(i2c_connect_client);

	gtp_irq_enable(ts);

	for (index = 0, len = 0; index < RsltIndex; ++index)
	{
		sprintf(&buf[len], "%s", result_lines[index]);
		len += strlen(result_lines[index]);
		kfree(result_lines[index]);
	}
	RsltIndex = 0;
	return len;
}

static ssize_t gtp_sysfs_shorttest_store(struct device *dev,struct device_attribute *attr, const char *buf, size_t count)
{
	return -EPERM;
}

static ssize_t gtp_sysfs_opentest_show(struct device *dev,struct device_attribute *attr, char *buf)
{
	s32 index;
	u32 len;
	int ret=0;
	struct goodix_ts_data *ts;

	ts = i2c_get_clientdata(i2c_connect_client);

	ret = gtp_wakeup_sleep(ts);
	gtp_irq_disable(ts);

	gt9xx_open_test(i2c_connect_client);

	gtp_irq_enable(ts);

	for (index = 0, len = 0; index < RsltIndex; ++index)
	{
		sprintf(&buf[len], "%s", result_lines[index]);
		len += strlen(result_lines[index]);
		kfree(result_lines[index]);
	}
	RsltIndex = 0;
	return len;
}

static ssize_t gtp_sysfs_opentest_store(struct device *dev,struct device_attribute *attr, const char *buf, size_t count)
{
	return -EPERM;
}

static DEVICE_ATTR(shorttest, S_IRUGO|S_IWUSR, gtp_sysfs_shorttest_show, gtp_sysfs_shorttest_store);
static DEVICE_ATTR(opentest, S_IRUGO|S_IWUSR, gtp_sysfs_opentest_show, gtp_sysfs_opentest_store);

// add by leo for dynamic change limit value ++
static ssize_t gtp_sysfs_tp_enable_show(struct device *dev,struct device_attribute *attr, char *buf)
{
	s32 index;
	ssize_t len;

	gt9xx_tp_enable(i2c_connect_client);

	for (index = 0, len = 0; index < RsltIndex; ++index)
	{
		sprintf(&buf[len], "%s", result_lines[index]);
		len += strlen(result_lines[index]);
		kfree(result_lines[index]);
	}
	RsltIndex = 0;
	return len;
}
static ssize_t gtp_sysfs_tp_enable_store(struct device *dev,struct device_attribute *attr, const char *buf, size_t count)
{
	return -EPERM;
}
static DEVICE_ATTR(tp_enable, S_IRUGO|S_IWUSR, gtp_sysfs_tp_enable_show, gtp_sysfs_tp_enable_store);

static ssize_t gtp_sysfs_tp_disable_show(struct device *dev,struct device_attribute *attr, char *buf)
{
	s32 index;
	ssize_t len;

	gt9xx_tp_disable(i2c_connect_client);

	for (index = 0, len = 0; index < RsltIndex; ++index)
	{
		sprintf(&buf[len], "%s", result_lines[index]);
		len += strlen(result_lines[index]);
		kfree(result_lines[index]);
	}
	RsltIndex = 0;
	return len;
}
static ssize_t gtp_sysfs_tp_disable_store(struct device *dev,struct device_attribute *attr, const char *buf, size_t count)
{
	return -EPERM;
}
static DEVICE_ATTR(tp_disable, S_IRUGO|S_IWUSR, gtp_sysfs_tp_disable_show, gtp_sysfs_tp_disable_store);

static ssize_t gt928_change_range_show(struct device *dev,struct device_attribute *attr, char *buf)
{
	return sprintf(buf,"TotalMaxValue = %d, TotalMinValue = %d\n", TotalMaxValue, TotalMinValue);
}

static ssize_t gt928_change_range_store(struct device *dev,struct device_attribute *attr, const char *buf, size_t count)
{
	int Max = 0, Min = 0;
	sscanf (buf, "%d %d", &Max, &Min);
	TotalMaxValue = Max;
	TotalMinValue = Min;

	printk("%s:[%d]: set TotalMaxValue = %d, TotalMinValue =%d\n", __func__, __LINE__,TotalMaxValue,TotalMinValue);

	return count;
}
static DEVICE_ATTR(gt928_limit, (S_IWUSR|S_IRUGO), gt928_change_range_show, gt928_change_range_store);

static ssize_t gt928_threshold_show(struct device *dev,struct device_attribute *attr, char *buf)
{
	return sprintf(buf,"gt900_short_threshold = %d\ngt900_resistor_threshold = %d\ngt900_resistor_warn_threshold = %d\ngt900_gnd_resistor_threshold = %d\ngt900_adc_read_delay = %d\ngt900_diffcode_short_threshold = %d\n",
	               gt900_short_threshold, gt900_resistor_threshold, gt900_resistor_warn_threshold, gt900_gnd_resistor_threshold, gt900_adc_read_delay, gt900_diffcode_short_threshold);
}

static ssize_t gt928_threshold_store(struct device *dev,struct device_attribute *attr, const char *buf, size_t count)
{
	int short_threshold=0,resistor_threshold=0,resistor_warn_threshold=0,gnd_resistor_threshold=0,adc_read_delay=0,diffcode_short_threshold=0;

	sscanf (buf, "%d %d %d %d %d %d", &short_threshold, &resistor_threshold, &resistor_warn_threshold,
	        &gnd_resistor_threshold, &adc_read_delay, &diffcode_short_threshold);
	printk("%s:[%d]: set gt900_short_threshold = %d\n", __func__, __LINE__,short_threshold);
	printk("%s:[%d]: set gt900_short_threshold = %d\n", __func__, __LINE__,resistor_threshold);
	printk("%s:[%d]: set gt900_short_threshold = %d\n", __func__, __LINE__,resistor_warn_threshold);
	printk("%s:[%d]: set gt900_short_threshold = %d\n", __func__, __LINE__,gnd_resistor_threshold);
	printk("%s:[%d]: set gt900_short_threshold = %d\n", __func__, __LINE__,adc_read_delay);
	printk("%s:[%d]: set gt900_short_threshold = %d\n", __func__, __LINE__,diffcode_short_threshold);

	gt900_short_threshold=short_threshold;
	gt900_resistor_threshold=resistor_threshold;
	gt900_resistor_warn_threshold=resistor_warn_threshold;
	gt900_gnd_resistor_threshold=gnd_resistor_threshold;
	gt900_adc_read_delay=adc_read_delay;
	gt900_diffcode_short_threshold=diffcode_short_threshold;

	return count;
}
static DEVICE_ATTR(gt928_thd, (S_IWUSR|S_IRUGO), gt928_threshold_show, gt928_threshold_store);
// add by leo for dynamic change limit value --

/*******************************************************
Description:
	Goodix debug sysfs init function.

Parameter:
	none.

return:
	Executive outcomes. 0---succeed.
*******************************************************/
s32 gtp_test_sysfs_init(void)
{
	s32 ret ;
	int i = 0;
	struct goodix_ts_data *ts = i2c_get_clientdata(i2c_connect_client);

	// add by leo for different TP source --
	if((ts->TP_ID == 0)||(ts->TP_ID == 1))
	{
		TotalMaxValue = TotalMaxValue_GIS;
		TotalMinValue = TotalMinValue_GIS;

		GTP_INFO("%s: GIS TP use GuitarTestPlatformINI_GIS", __func__);
		for(i=0; i<TOTAL_PIXEL_NUM*4; i++)
		{
			GuitarTestPlatformINI[i]=GuitarTestPlatformINI_GIS[i];
		}
	}
	else if((ts->TP_ID == 2)||(ts->TP_ID == 3))
	{
		TotalMaxValue = TotalMaxValue_TopTouch;
		TotalMinValue = TotalMinValue_TopTouch;

		GTP_INFO("%s: TopTouch TP use GuitarTestPlatformINI_TOPTOUCH", __func__);
		for(i=0; i<TOTAL_PIXEL_NUM*4; i++)
		{
			GuitarTestPlatformINI[i]=GuitarTestPlatformINI_TOPTOUCH[i];
		}
	}
	else
	{
		TotalMaxValue = TotalMaxValue_GIS;
		TotalMinValue = TotalMinValue_GIS;

		GTP_ERROR("%s: Unknow TP use default GuitarTestPlatformINI_GIS", __func__);
		for(i=0; i<TOTAL_PIXEL_NUM*4; i++)
		{
			GuitarTestPlatformINI[i]=GuitarTestPlatformINI_GIS[i];
		}
	}
	// add by leo for different TP source --

	goodix_debug_kobj = kobject_create_and_add("gtp_test", NULL) ;
	SET_INFO_LINE_INFO("Starting initlizing gtp_debug_sysfs");
	if (goodix_debug_kobj == NULL)
	{
		GTP_ERROR("%s: subsystem_register failed\n", __func__);
		return -ENOMEM;
	}

	ret = sysfs_create_file(goodix_debug_kobj, &dev_attr_shorttest.attr);
	if (ret)
	{
		GTP_ERROR("%s: sysfs create shorttest file failed\n", __func__);
		return ret;
	}
	ret = sysfs_create_file(goodix_debug_kobj, &dev_attr_opentest.attr);
	if (ret)
	{
		GTP_ERROR("%s: sysfs create opentes file failed\n", __func__);
		return ret;
	}

	// add by leo for dynamic change limit value ++
	ret = sysfs_create_file(goodix_debug_kobj, &dev_attr_tp_disable.attr);
	if (ret)
	{
		GTP_ERROR("%s: sysfs_create_version_file failed\n", __func__);
		return ret;
	}

	ret = sysfs_create_file(goodix_debug_kobj, &dev_attr_tp_enable.attr);
	if (ret)
	{
		GTP_ERROR("%s: sysfs_create_version_file failed\n", __func__);
		return ret;
	}

	ret = sysfs_create_file(goodix_debug_kobj, &dev_attr_gt928_limit.attr);
	if (ret)
	{
		GTP_ERROR("%s: sysfs create gt928_limit file failed\n", __func__);
		return ret;
	}

	ret = sysfs_create_file(goodix_debug_kobj, &dev_attr_gt928_thd.attr);
	if (ret)
	{
		GTP_ERROR("%s: sysfs create gt928_threshold file failed\n", __func__);
		return ret;
	}
	// add by leo for dynamic change limit value --

	GTP_INFO("Goodix debug sysfs create success!");
	return 0 ;
}

void gtp_test_sysfs_deinit(void)
{
	sysfs_remove_file(goodix_debug_kobj, &dev_attr_shorttest.attr);
	sysfs_remove_file(goodix_debug_kobj, &dev_attr_opentest.attr);
	kobject_del(goodix_debug_kobj);

	return;
}

// add by leo for dump raw data ++
static int gt928_reload_test_matrix(void)
{
	int i=0, j=1, k=0, len=0, begin=1, end=0, num=0, x=1;
	struct file *filp=NULL;
	mm_segment_t old_fs;
	u8 *temp=NULL;
	u16 *raw_acc_info=NULL;

	// 767,xxxx,xxxx,xxx,
	temp = (u8*)kmalloc(sizeof(u8)* gt9xx_sc_pxl_cnt*18, GFP_KERNEL);
	raw_acc_info = (u16*)kmalloc(sizeof(u16)* gt9xx_sc_pxl_cnt*18, GFP_KERNEL);

	memset(temp, 0, sizeof(u8)* gt9xx_sc_pxl_cnt*18);
	memset(raw_acc_info, 0, sizeof(u16)* gt9xx_sc_pxl_cnt*18);

	filp=filp_open(TEST_CONFIG_FILE_PATH,O_RDWR|O_CREAT,S_IRWXU|S_IRWXG|S_IRWXO);
	if (IS_ERR_OR_NULL(filp))
	{
		printk("%s:[%d]: TEST_CONFIG_FILE_PATH Open Failed \n",__FUNCTION__, __LINE__);
		return -ENOENT;
	}

	if(filp->f_op != NULL && filp->f_op->read != NULL)
	{
		old_fs = get_fs();
		set_fs(KERNEL_DS);

		len = filp->f_op->read(filp, temp, gt9xx_sc_pxl_cnt*18, &filp->f_pos);
		//gt928_raw_acc_spec=&temp;
		set_fs(old_fs);
	}

	printk("%s:[%d]: len=%d\n",__FUNCTION__, __LINE__,len);
	filp_close(filp,NULL);

	raw_acc_info[0]=temp[0]-48;
	for(i=2; i<len; i++)
	{
		//printk("%d\n",i);
		x=1;
		if(temp[i]==',')
		{
			end=begin;
			begin=i;
			num=(begin-end)-1;

			//printk("%s:[%d]: end=%d, begin=%d, num=%d\n",__FUNCTION__, __LINE__,end,begin,num);
			for(k=num; k>0; k--)
			{
				//printk("%s:[%d]: raw_acc_info[%d]=%d\n",__FUNCTION__, __LINE__,j,temp[end+k]-48);
				//printk("%s:[%d]: raw_acc_info[%d]=%d\n",__FUNCTION__, __LINE__,j,(temp[end+k]-48)*x);
				raw_acc_info[j]+=(temp[end+k]-48)*x;
				x*=10;
			}
			//printk("%s:[%d]: end=%d, begin=%d, num=%d, raw_acc_info[%d]=%d\n",__FUNCTION__, __LINE__,end,begin,num,j,raw_acc_info[j]);
			j++;
		}
	}

	for(i=0; i<TOTAL_PIXEL_NUM*4; i++)
	{
		if((i!=0)&&(i%32==0))
		{
			printk("\n");
		}
		GuitarTestPlatformINI[i]=raw_acc_info[i];
		printk("%d ",GuitarTestPlatformINI[i]);
	}
	printk("\n");

	kfree(temp);
	kfree(raw_acc_info);
	return 0;
}

static ssize_t gt928_proc_test_read(struct seq_file *buf, void *v)
{
	//int i=0;

	seq_printf(buf, "%s\n\n",(test_result==SUCCESS)?"PASS":"FAIL");

	return 0;
}

static ssize_t gt928_proc_test_write(struct file *filp, const char __user *buf, size_t len, loff_t *data)
{
	if(buf[0] == 't') // total opentest
	{
		printk("%s:[%d]: Total Max and Min Open Test \n", __func__, __LINE__);
		AreaAccordCheck=false;
		AbsoluteTotalCheck=true;

		printk("%s:[%d]: AbsoluteTotalCheck = %s, TotalMaxValue = %d, TotalMinValue = %d \n", __func__, __LINE__
		       ,(AbsoluteTotalCheck)?"true":"false",TotalMaxValue,TotalMinValue);
	}
	if(buf[0] == 's') // single point opentest
	{
		printk("%s:[%d]: Single Max and Min Open Test \n", __func__, __LINE__);
		AreaAccordCheck=false;
		AbsoluteTotalCheck=false;

		printk("%s:[%d]: AbsoluteTotalCheck = %s \n", __func__, __LINE__
		       ,(AbsoluteTotalCheck)?"true":"false");
	}
	if(buf[0] == 'a') // single Area Accord Check
	{
		printk("%s:[%d]: Area Accored Test \n", __func__, __LINE__);
		AreaAccordCheck=true;

		printk("%s:[%d]: AreaAccordCheck = %s \n", __func__, __LINE__
		       ,(AreaAccordCheck)?"true":"false");
	}

	if((buf[0] == 'r')&&(buf[1] == 'e')&&(buf[2] == 'l')&&(buf[3] == 'o')&&(buf[4] == 'a')&&(buf[5] == 'd'))
	{
		printk("%s:[%d]: reloade Guitar Test Platform ini data !\n", __func__, __LINE__);
		gt928_reload_test_matrix();
	}

	return len;
}

static int gt928_proc_test_open(struct inode *inode, struct  file *file)
{
	return single_open(file, gt928_proc_test_read, NULL);
}

static const struct file_operations gt928_test_fops =
{
	.owner = THIS_MODULE,
	.open = gt928_proc_test_open,
	.read = seq_read,
	.write = gt928_proc_test_write,
};

void gt928_create_proc_test_file(void)
{
	gt928_proc_test_file = proc_create(GT928_PROC_TEST_FILE, 0666, NULL, &gt928_test_fops);
	if(gt928_proc_test_file)
	{
		GTP_INFO("%s:[%d]: proc test file create sucessed!", __func__, __LINE__);
	}
	else
	{
		GTP_ERROR("%s:[%d]: proc test file create failed!", __func__, __LINE__);
	}

	return;
}

void gt928_remove_proc_test_file(void)
{
	extern struct proc_dir_entry proc_root;
	printk("%s:[%d]: proc test file removed\n", __func__, __LINE__);
	remove_proc_entry(GT928_PROC_TEST_FILE, &proc_root);

	return;
}

static ssize_t gt928_proc_diag_read(struct seq_file *buf, void *v)
{
	int i=0;

	// Raw Data
	seq_printf(buf, "Raw Data[%d]:\n", gt9xx_sc_pxl_cnt);
	for(i=0; i<gt9xx_sc_pxl_cnt; i++)
	{
		if((i!=0)&&(i%gt9xx_drv_num==0))
		{
			//printk("\n");
			seq_printf(buf, "\n");
		}
		//printk("%d ",gt928_raw_data[i]);
		seq_printf(buf, "%d ",gt928_raw_data[i]);
	}
	//printk("\n");
	seq_printf(buf, "\n");

	//printk("\n\n");
	seq_printf(buf, "\n");

	// Area Accord Data
	if(AreaAccordCheck)
	{
		seq_printf(buf, "Area Accord Data[%d]:\n", gt9xx_sc_pxl_cnt);
		for(i=0; i<gt9xx_sc_pxl_cnt; i++)
		{
			if((i!=0)&&(i%gt9xx_drv_num==0))
			{
				//printk("\n");
				seq_printf(buf, "\n");
			}
			//printk("%04d ",gt928_acc_data[i]);
			seq_printf(buf, "%04d ",gt928_acc_data[i]);
		}
		//printk("\n");
		seq_printf(buf, "\n");

		//printk("\n\n");
		seq_printf(buf, "\n");
	}

	// Guitar Test Platform Data
	if((!AbsoluteTotalCheck)||AreaAccordCheck)
	{
		seq_printf(buf, "Guitar Test Platform INI Data[%d]:\n", sizeof(GuitarTestPlatformINI)/sizeof(u16));
		for(i=0; i<TOTAL_PIXEL_NUM*4; i++)
		{
			if((i!=0)&&(i%gt9xx_drv_num==0))
			{
				//printk("\n");
				seq_printf(buf, "\n");
			}
			//printk("%d ",GuitarTestPlatformINI[i]);
			seq_printf(buf, "%d ",GuitarTestPlatformINI[i]);
		}
		//printk("\n");
		seq_printf(buf, "\n");

		//printk("\n\n");
		seq_printf(buf, "\n");
	}
	return 0;
}

static ssize_t gt928_proc_diag_write(struct file *filp, const char __user *buf, size_t len, loff_t *data)
{
	return len;
}

static int gt928_proc_diag_open(struct inode *inode, struct  file *file)
{
	return single_open(file, gt928_proc_diag_read, NULL);
}

static const struct file_operations gt928_diag_fops =
{
	.owner = THIS_MODULE,
	.open = gt928_proc_diag_open,
	.read = seq_read,
	.write = gt928_proc_diag_write,
};

void gt928_create_proc_diag_file(void)
{
	gt928_proc_diag_file = proc_create(GT928_PROC_DIAG_FILE, 0666, NULL, &gt928_diag_fops);
	if(gt928_proc_diag_file)
	{
		GTP_INFO("%s:[%d]: proc diag file create sucessed!", __func__, __LINE__);
	}
	else
	{
		GTP_ERROR("%s:[%d]: proc diag file create failed!", __func__, __LINE__);
	}

	return;
}

void gt928_remove_proc_diag_file(void)
{
	extern struct proc_dir_entry proc_root;
	GTP_INFO("%s:[%d]: proc diag file removed", __func__, __LINE__);
	remove_proc_entry(GT928_PROC_DIAG_FILE, &proc_root);

	return;
}
// add by leo for dump raw data --
